{"ast":null,"code":"/* jshint forin: false, bitwise: false */\n\n/*\nCopyright 2015-2021 Esri\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nA copy of the license and additional notices are located with the\nsource distribution at:\n\nhttp://github.com/Esri/lerc/\n\nContributors:  Johannes Schmid, (LERC v1)\n               Chayanika Khatua, (LERC v1)\n               Wenxue Ju (LERC v1, v2.x)\n*/\n\n/* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */\n\n/**\n * a module for decoding LERC blobs\n * @module Lerc\n */\n(function () {\n  //this decoder supports all lerc versions, each version has its own class (LercDecode and Lerc2Decode). \n  //the exported module handles format variation autoamtically.\n  //the original LercDecode for Version 1\n  var LercDecode = function () {\n    // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of\n    // the class was chosen to be future proof.\n    var CntZImage = {};\n    CntZImage.defaultNoDataValue = -3.4027999387901484e+38; // smallest Float32 value\n\n    /**\n     * Decode a LERC byte stream and return an object containing the pixel data and some required and optional\n     * information about it, such as the image's width and height.\n     *\n     * @param {ArrayBuffer} input The LERC input byte stream\n     * @param {object} [options] Decoding options, containing any of the following properties:\n     * @config {number} [inputOffset = 0]\n     *        Skip the first inputOffset bytes of the input byte stream. A valid LERC file is expected at that position.\n     * @config {Uint8Array} [encodedMask = null]\n     *        If specified, the decoder will not read mask information from the input and use the specified encoded\n     *        mask data instead. Mask header/data must not be present in the LERC byte stream in this case.\n     * @config {number} [noDataValue = LercCode.defaultNoDataValue]\n     *        Pixel value to use for masked pixels.\n     * @config {ArrayBufferView|Array} [pixelType = Float32Array]\n     *        The desired type of the pixelData array in the return value. Note that it is the caller's responsibility to\n     *        provide an appropriate noDataValue if the default pixelType is overridden.\n     * @config {boolean} [returnMask = false]\n     *        If true, the return value will contain a maskData property of type Uint8Array which has one element per\n     *        pixel, the value of which is 1 or 0 depending on whether that pixel's data is present or masked. If the\n     *        input LERC data does not contain a mask, maskData will not be returned.\n     * @config {boolean} [returnEncodedMask = false]\n     *        If true, the return value will contain a encodedMaskData property, which can be passed into encode() as\n     *        encodedMask.\n     * @config {boolean} [returnFileInfo = false]\n     *        If true, the return value will have a fileInfo property that contains metadata obtained from the\n     *        LERC headers and the decoding process.\n     * @config {boolean} [computeUsedBitDepths = false]\n     *        If true, the fileInfo property in the return value will contain the set of all block bit depths\n     *        encountered during decoding. Will only have an effect if returnFileInfo option is true.\n     * @returns {{width, height, pixelData, minValue, maxValue, noDataValue, maskData, encodedMaskData, fileInfo}}\n     */\n\n    CntZImage.decode = function (input, options) {\n      options = options || {};\n      var skipMask = options.encodedMaskData || options.encodedMaskData === null;\n      var parsedData = parse(input, options.inputOffset || 0, skipMask);\n      var noDataValue = options.noDataValue !== null ? options.noDataValue : CntZImage.defaultNoDataValue;\n      var uncompressedData = uncompressPixelValues(parsedData, options.pixelType || Float32Array, options.encodedMaskData, noDataValue, options.returnMask);\n      var result = {\n        width: parsedData.width,\n        height: parsedData.height,\n        pixelData: uncompressedData.resultPixels,\n        minValue: uncompressedData.minValue,\n        maxValue: parsedData.pixels.maxValue,\n        noDataValue: noDataValue\n      };\n\n      if (uncompressedData.resultMask) {\n        result.maskData = uncompressedData.resultMask;\n      }\n\n      if (options.returnEncodedMask && parsedData.mask) {\n        result.encodedMaskData = parsedData.mask.bitset ? parsedData.mask.bitset : null;\n      }\n\n      if (options.returnFileInfo) {\n        result.fileInfo = formatFileInfo(parsedData);\n\n        if (options.computeUsedBitDepths) {\n          result.fileInfo.bitDepths = computeUsedBitDepths(parsedData);\n        }\n      }\n\n      return result;\n    };\n\n    var uncompressPixelValues = function (data, TypedArrayClass, maskBitset, noDataValue, storeDecodedMask) {\n      var blockIdx = 0;\n      var numX = data.pixels.numBlocksX;\n      var numY = data.pixels.numBlocksY;\n      var blockWidth = Math.floor(data.width / numX);\n      var blockHeight = Math.floor(data.height / numY);\n      var scale = 2 * data.maxZError;\n      var minValue = Number.MAX_VALUE,\n          currentValue;\n      maskBitset = maskBitset || (data.mask ? data.mask.bitset : null);\n      var resultPixels, resultMask;\n      resultPixels = new TypedArrayClass(data.width * data.height);\n\n      if (storeDecodedMask && maskBitset) {\n        resultMask = new Uint8Array(data.width * data.height);\n      }\n\n      var blockDataBuffer = new Float32Array(blockWidth * blockHeight);\n      var xx, yy;\n\n      for (var y = 0; y <= numY; y++) {\n        var thisBlockHeight = y !== numY ? blockHeight : data.height % numY;\n\n        if (thisBlockHeight === 0) {\n          continue;\n        }\n\n        for (var x = 0; x <= numX; x++) {\n          var thisBlockWidth = x !== numX ? blockWidth : data.width % numX;\n\n          if (thisBlockWidth === 0) {\n            continue;\n          }\n\n          var outPtr = y * data.width * blockHeight + x * blockWidth;\n          var outStride = data.width - thisBlockWidth;\n          var block = data.pixels.blocks[blockIdx];\n          var blockData, blockPtr, constValue;\n\n          if (block.encoding < 2) {\n            // block is either uncompressed or bit-stuffed (encodings 0 and 1)\n            if (block.encoding === 0) {\n              // block is uncompressed\n              blockData = block.rawData;\n            } else {\n              // block is bit-stuffed\n              unstuff(block.stuffedData, block.bitsPerPixel, block.numValidPixels, block.offset, scale, blockDataBuffer, data.pixels.maxValue);\n              blockData = blockDataBuffer;\n            }\n\n            blockPtr = 0;\n          } else if (block.encoding === 2) {\n            // block is all 0\n            constValue = 0;\n          } else {\n            // block has constant value (encoding === 3)\n            constValue = block.offset;\n          }\n\n          var maskByte;\n\n          if (maskBitset) {\n            for (yy = 0; yy < thisBlockHeight; yy++) {\n              if (outPtr & 7) {\n                //\n                maskByte = maskBitset[outPtr >> 3];\n                maskByte <<= outPtr & 7;\n              }\n\n              for (xx = 0; xx < thisBlockWidth; xx++) {\n                if (!(outPtr & 7)) {\n                  // read next byte from mask\n                  maskByte = maskBitset[outPtr >> 3];\n                }\n\n                if (maskByte & 128) {\n                  // pixel data present\n                  if (resultMask) {\n                    resultMask[outPtr] = 1;\n                  }\n\n                  currentValue = block.encoding < 2 ? blockData[blockPtr++] : constValue;\n                  minValue = minValue > currentValue ? currentValue : minValue;\n                  resultPixels[outPtr++] = currentValue;\n                } else {\n                  // pixel data not present\n                  if (resultMask) {\n                    resultMask[outPtr] = 0;\n                  }\n\n                  resultPixels[outPtr++] = noDataValue;\n                }\n\n                maskByte <<= 1;\n              }\n\n              outPtr += outStride;\n            }\n          } else {\n            // mask not present, simply copy block over\n            if (block.encoding < 2) {\n              // duplicating this code block for performance reasons\n              // blockData case:\n              for (yy = 0; yy < thisBlockHeight; yy++) {\n                for (xx = 0; xx < thisBlockWidth; xx++) {\n                  currentValue = blockData[blockPtr++];\n                  minValue = minValue > currentValue ? currentValue : minValue;\n                  resultPixels[outPtr++] = currentValue;\n                }\n\n                outPtr += outStride;\n              }\n            } else {\n              // constValue case:\n              minValue = minValue > constValue ? constValue : minValue;\n\n              for (yy = 0; yy < thisBlockHeight; yy++) {\n                for (xx = 0; xx < thisBlockWidth; xx++) {\n                  resultPixels[outPtr++] = constValue;\n                }\n\n                outPtr += outStride;\n              }\n            }\n          }\n\n          if (block.encoding === 1 && blockPtr !== block.numValidPixels) {\n            throw \"Block and Mask do not match\";\n          }\n\n          blockIdx++;\n        }\n      }\n\n      return {\n        resultPixels: resultPixels,\n        resultMask: resultMask,\n        minValue: minValue\n      };\n    };\n\n    var formatFileInfo = function (data) {\n      return {\n        \"fileIdentifierString\": data.fileIdentifierString,\n        \"fileVersion\": data.fileVersion,\n        \"imageType\": data.imageType,\n        \"height\": data.height,\n        \"width\": data.width,\n        \"maxZError\": data.maxZError,\n        \"eofOffset\": data.eofOffset,\n        \"mask\": data.mask ? {\n          \"numBlocksX\": data.mask.numBlocksX,\n          \"numBlocksY\": data.mask.numBlocksY,\n          \"numBytes\": data.mask.numBytes,\n          \"maxValue\": data.mask.maxValue\n        } : null,\n        \"pixels\": {\n          \"numBlocksX\": data.pixels.numBlocksX,\n          \"numBlocksY\": data.pixels.numBlocksY,\n          \"numBytes\": data.pixels.numBytes,\n          \"maxValue\": data.pixels.maxValue,\n          \"noDataValue\": data.noDataValue\n        }\n      };\n    };\n\n    var computeUsedBitDepths = function (data) {\n      var numBlocks = data.pixels.numBlocksX * data.pixels.numBlocksY;\n      var bitDepths = {};\n\n      for (var i = 0; i < numBlocks; i++) {\n        var block = data.pixels.blocks[i];\n\n        if (block.encoding === 0) {\n          bitDepths.float32 = true;\n        } else if (block.encoding === 1) {\n          bitDepths[block.bitsPerPixel] = true;\n        } else {\n          bitDepths[0] = true;\n        }\n      }\n\n      return Object.keys(bitDepths);\n    };\n\n    var parse = function (input, fp, skipMask) {\n      var data = {}; // File header\n\n      var fileIdView = new Uint8Array(input, fp, 10);\n      data.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\n\n      if (data.fileIdentifierString.trim() !== \"CntZImage\") {\n        throw \"Unexpected file identifier string: \" + data.fileIdentifierString;\n      }\n\n      fp += 10;\n      var view = new DataView(input, fp, 24);\n      data.fileVersion = view.getInt32(0, true);\n      data.imageType = view.getInt32(4, true);\n      data.height = view.getUint32(8, true);\n      data.width = view.getUint32(12, true);\n      data.maxZError = view.getFloat64(16, true);\n      fp += 24; // Mask Header\n\n      if (!skipMask) {\n        view = new DataView(input, fp, 16);\n        data.mask = {};\n        data.mask.numBlocksY = view.getUint32(0, true);\n        data.mask.numBlocksX = view.getUint32(4, true);\n        data.mask.numBytes = view.getUint32(8, true);\n        data.mask.maxValue = view.getFloat32(12, true);\n        fp += 16; // Mask Data\n\n        if (data.mask.numBytes > 0) {\n          var bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));\n          view = new DataView(input, fp, data.mask.numBytes);\n          var cnt = view.getInt16(0, true);\n          var ip = 2,\n              op = 0;\n\n          do {\n            if (cnt > 0) {\n              while (cnt--) {\n                bitset[op++] = view.getUint8(ip++);\n              }\n            } else {\n              var val = view.getUint8(ip++);\n              cnt = -cnt;\n\n              while (cnt--) {\n                bitset[op++] = val;\n              }\n            }\n\n            cnt = view.getInt16(ip, true);\n            ip += 2;\n          } while (ip < data.mask.numBytes);\n\n          if (cnt !== -32768 || op < bitset.length) {\n            throw \"Unexpected end of mask RLE encoding\";\n          }\n\n          data.mask.bitset = bitset;\n          fp += data.mask.numBytes;\n        } else if ((data.mask.numBytes | data.mask.numBlocksY | data.mask.maxValue) === 0) {\n          // Special case, all nodata\n          data.mask.bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));\n        }\n      } // Pixel Header\n\n\n      view = new DataView(input, fp, 16);\n      data.pixels = {};\n      data.pixels.numBlocksY = view.getUint32(0, true);\n      data.pixels.numBlocksX = view.getUint32(4, true);\n      data.pixels.numBytes = view.getUint32(8, true);\n      data.pixels.maxValue = view.getFloat32(12, true);\n      fp += 16;\n      var numBlocksX = data.pixels.numBlocksX;\n      var numBlocksY = data.pixels.numBlocksY; // the number of blocks specified in the header does not take into account the blocks at the end of\n      // each row/column with a special width/height that make the image complete in case the width is not\n      // evenly divisible by the number of blocks.\n\n      var actualNumBlocksX = numBlocksX + (data.width % numBlocksX > 0 ? 1 : 0);\n      var actualNumBlocksY = numBlocksY + (data.height % numBlocksY > 0 ? 1 : 0);\n      data.pixels.blocks = new Array(actualNumBlocksX * actualNumBlocksY);\n      var blockI = 0;\n\n      for (var blockY = 0; blockY < actualNumBlocksY; blockY++) {\n        for (var blockX = 0; blockX < actualNumBlocksX; blockX++) {\n          // Block\n          var size = 0;\n          var bytesLeft = input.byteLength - fp;\n          view = new DataView(input, fp, Math.min(10, bytesLeft));\n          var block = {};\n          data.pixels.blocks[blockI++] = block;\n          var headerByte = view.getUint8(0);\n          size++;\n          block.encoding = headerByte & 63;\n\n          if (block.encoding > 3) {\n            throw \"Invalid block encoding (\" + block.encoding + \")\";\n          }\n\n          if (block.encoding === 2) {\n            fp++;\n            continue;\n          }\n\n          if (headerByte !== 0 && headerByte !== 2) {\n            headerByte >>= 6;\n            block.offsetType = headerByte;\n\n            if (headerByte === 2) {\n              block.offset = view.getInt8(1);\n              size++;\n            } else if (headerByte === 1) {\n              block.offset = view.getInt16(1, true);\n              size += 2;\n            } else if (headerByte === 0) {\n              block.offset = view.getFloat32(1, true);\n              size += 4;\n            } else {\n              throw \"Invalid block offset type\";\n            }\n\n            if (block.encoding === 1) {\n              headerByte = view.getUint8(size);\n              size++;\n              block.bitsPerPixel = headerByte & 63;\n              headerByte >>= 6;\n              block.numValidPixelsType = headerByte;\n\n              if (headerByte === 2) {\n                block.numValidPixels = view.getUint8(size);\n                size++;\n              } else if (headerByte === 1) {\n                block.numValidPixels = view.getUint16(size, true);\n                size += 2;\n              } else if (headerByte === 0) {\n                block.numValidPixels = view.getUint32(size, true);\n                size += 4;\n              } else {\n                throw \"Invalid valid pixel count type\";\n              }\n            }\n          }\n\n          fp += size;\n\n          if (block.encoding === 3) {\n            continue;\n          }\n\n          var arrayBuf, store8;\n\n          if (block.encoding === 0) {\n            var numPixels = (data.pixels.numBytes - 1) / 4;\n\n            if (numPixels !== Math.floor(numPixels)) {\n              throw \"uncompressed block has invalid length\";\n            }\n\n            arrayBuf = new ArrayBuffer(numPixels * 4);\n            store8 = new Uint8Array(arrayBuf);\n            store8.set(new Uint8Array(input, fp, numPixels * 4));\n            var rawData = new Float32Array(arrayBuf);\n            block.rawData = rawData;\n            fp += numPixels * 4;\n          } else if (block.encoding === 1) {\n            var dataBytes = Math.ceil(block.numValidPixels * block.bitsPerPixel / 8);\n            var dataWords = Math.ceil(dataBytes / 4);\n            arrayBuf = new ArrayBuffer(dataWords * 4);\n            store8 = new Uint8Array(arrayBuf);\n            store8.set(new Uint8Array(input, fp, dataBytes));\n            block.stuffedData = new Uint32Array(arrayBuf);\n            fp += dataBytes;\n          }\n        }\n      }\n\n      data.eofOffset = fp;\n      return data;\n    };\n\n    var unstuff = function (src, bitsPerPixel, numPixels, offset, scale, dest, maxValue) {\n      var bitMask = (1 << bitsPerPixel) - 1;\n      var i = 0,\n          o;\n      var bitsLeft = 0;\n      var n, buffer;\n      var nmax = Math.ceil((maxValue - offset) / scale); // get rid of trailing bytes that are already part of next block\n\n      var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n      src[src.length - 1] <<= 8 * numInvalidTailBytes;\n\n      for (o = 0; o < numPixels; o++) {\n        if (bitsLeft === 0) {\n          buffer = src[i++];\n          bitsLeft = 32;\n        }\n\n        if (bitsLeft >= bitsPerPixel) {\n          n = buffer >>> bitsLeft - bitsPerPixel & bitMask;\n          bitsLeft -= bitsPerPixel;\n        } else {\n          var missingBits = bitsPerPixel - bitsLeft;\n          n = (buffer & bitMask) << missingBits & bitMask;\n          buffer = src[i++];\n          bitsLeft = 32 - missingBits;\n          n += buffer >>> bitsLeft;\n        } //pixel values may exceed max due to quantization\n\n\n        dest[o] = n < nmax ? offset + n * scale : maxValue;\n      }\n\n      return dest;\n    };\n\n    return CntZImage;\n  }(); //version 2. Supports 2.1, 2.2, 2.3\n\n\n  var Lerc2Decode = function () {\n    \"use strict\"; // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of\n    // the class was chosen to be future proof, following LercDecode.\n\n    /*****************************************\n    * private static class bitsutffer used by Lerc2Decode\n    *******************************************/\n\n    var BitStuffer = {\n      //methods ending with 2 are for the new byte order used by Lerc2.3 and above.\n      //originalUnstuff is used to unpack Huffman code table. code is duplicated to unstuffx for performance reasons.\n      unstuff: function (src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0,\n            o;\n        var bitsLeft = 0;\n        var n, buffer, missingBits, nmax; // get rid of trailing bytes that are already part of next block\n\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\n\n        if (lutArr) {\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n            }\n\n            if (bitsLeft >= bitsPerPixel) {\n              n = buffer >>> bitsLeft - bitsPerPixel & bitMask;\n              bitsLeft -= bitsPerPixel;\n            } else {\n              missingBits = bitsPerPixel - bitsLeft;\n              n = (buffer & bitMask) << missingBits & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n += buffer >>> bitsLeft;\n            }\n\n            dest[o] = lutArr[n]; //offset + lutArr[n] * scale;\n          }\n        } else {\n          nmax = Math.ceil((maxValue - offset) / scale);\n\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n            }\n\n            if (bitsLeft >= bitsPerPixel) {\n              n = buffer >>> bitsLeft - bitsPerPixel & bitMask;\n              bitsLeft -= bitsPerPixel;\n            } else {\n              missingBits = bitsPerPixel - bitsLeft;\n              n = (buffer & bitMask) << missingBits & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n += buffer >>> bitsLeft;\n            } //pixel values may exceed max due to quantization\n\n\n            dest[o] = n < nmax ? offset + n * scale : maxValue;\n          }\n        }\n      },\n      unstuffLUT: function (src, bitsPerPixel, numPixels, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0,\n            o = 0,\n            missingBits = 0,\n            bitsLeft = 0,\n            n = 0;\n        var buffer;\n        var dest = []; // get rid of trailing bytes that are already part of next block\n\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\n        var nmax = Math.ceil((maxValue - offset) / scale);\n\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n          }\n\n          if (bitsLeft >= bitsPerPixel) {\n            n = buffer >>> bitsLeft - bitsPerPixel & bitMask;\n            bitsLeft -= bitsPerPixel;\n          } else {\n            missingBits = bitsPerPixel - bitsLeft;\n            n = (buffer & bitMask) << missingBits & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n += buffer >>> bitsLeft;\n          } //dest.push(n);\n\n\n          dest[o] = n < nmax ? offset + n * scale : maxValue;\n        }\n\n        dest.unshift(offset); //1st one\n\n        return dest;\n      },\n      unstuff2: function (src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0,\n            o;\n        var bitsLeft = 0,\n            bitPos = 0;\n        var n, buffer, missingBits;\n\n        if (lutArr) {\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n              bitPos = 0;\n            }\n\n            if (bitsLeft >= bitsPerPixel) {\n              n = buffer >>> bitPos & bitMask;\n              bitsLeft -= bitsPerPixel;\n              bitPos += bitsPerPixel;\n            } else {\n              missingBits = bitsPerPixel - bitsLeft;\n              n = buffer >>> bitPos & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n |= (buffer & (1 << missingBits) - 1) << bitsPerPixel - missingBits;\n              bitPos = missingBits;\n            }\n\n            dest[o] = lutArr[n];\n          }\n        } else {\n          var nmax = Math.ceil((maxValue - offset) / scale);\n\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n              bitPos = 0;\n            }\n\n            if (bitsLeft >= bitsPerPixel) {\n              //no unsigned left shift\n              n = buffer >>> bitPos & bitMask;\n              bitsLeft -= bitsPerPixel;\n              bitPos += bitsPerPixel;\n            } else {\n              missingBits = bitsPerPixel - bitsLeft;\n              n = buffer >>> bitPos & bitMask; //((buffer & bitMask) << missingBits) & bitMask;\n\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n |= (buffer & (1 << missingBits) - 1) << bitsPerPixel - missingBits;\n              bitPos = missingBits;\n            } //pixel values may exceed max due to quantization\n\n\n            dest[o] = n < nmax ? offset + n * scale : maxValue;\n          }\n        }\n\n        return dest;\n      },\n      unstuffLUT2: function (src, bitsPerPixel, numPixels, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0,\n            o = 0,\n            missingBits = 0,\n            bitsLeft = 0,\n            n = 0,\n            bitPos = 0;\n        var buffer;\n        var dest = [];\n        var nmax = Math.ceil((maxValue - offset) / scale);\n\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n            bitPos = 0;\n          }\n\n          if (bitsLeft >= bitsPerPixel) {\n            //no unsigned left shift\n            n = buffer >>> bitPos & bitMask;\n            bitsLeft -= bitsPerPixel;\n            bitPos += bitsPerPixel;\n          } else {\n            missingBits = bitsPerPixel - bitsLeft;\n            n = buffer >>> bitPos & bitMask; //((buffer & bitMask) << missingBits) & bitMask;\n\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n |= (buffer & (1 << missingBits) - 1) << bitsPerPixel - missingBits;\n            bitPos = missingBits;\n          } //dest.push(n);\n\n\n          dest[o] = n < nmax ? offset + n * scale : maxValue;\n        }\n\n        dest.unshift(offset);\n        return dest;\n      },\n      originalUnstuff: function (src, dest, bitsPerPixel, numPixels) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0,\n            o;\n        var bitsLeft = 0;\n        var n, buffer, missingBits; // get rid of trailing bytes that are already part of next block\n\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\n\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n          }\n\n          if (bitsLeft >= bitsPerPixel) {\n            n = buffer >>> bitsLeft - bitsPerPixel & bitMask;\n            bitsLeft -= bitsPerPixel;\n          } else {\n            missingBits = bitsPerPixel - bitsLeft;\n            n = (buffer & bitMask) << missingBits & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n += buffer >>> bitsLeft;\n          }\n\n          dest[o] = n;\n        }\n\n        return dest;\n      },\n      originalUnstuff2: function (src, dest, bitsPerPixel, numPixels) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0,\n            o;\n        var bitsLeft = 0,\n            bitPos = 0;\n        var n, buffer, missingBits; //micro-optimizations\n\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n            bitPos = 0;\n          }\n\n          if (bitsLeft >= bitsPerPixel) {\n            //no unsigned left shift\n            n = buffer >>> bitPos & bitMask;\n            bitsLeft -= bitsPerPixel;\n            bitPos += bitsPerPixel;\n          } else {\n            missingBits = bitsPerPixel - bitsLeft;\n            n = buffer >>> bitPos & bitMask; //((buffer & bitMask) << missingBits) & bitMask;\n\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n |= (buffer & (1 << missingBits) - 1) << bitsPerPixel - missingBits;\n            bitPos = missingBits;\n          }\n\n          dest[o] = n;\n        }\n\n        return dest;\n      }\n    };\n    /*****************************************\n    *private static class used by Lerc2Decode\n    ******************************************/\n\n    var Lerc2Helpers = {\n      HUFFMAN_LUT_BITS_MAX: 12,\n      //use 2^12 lut, treat it like constant\n      computeChecksumFletcher32: function (input) {\n        var sum1 = 0xffff,\n            sum2 = 0xffff;\n        var len = input.length;\n        var words = Math.floor(len / 2);\n        var i = 0;\n\n        while (words) {\n          var tlen = words >= 359 ? 359 : words;\n          words -= tlen;\n\n          do {\n            sum1 += input[i++] << 8;\n            sum2 += sum1 += input[i++];\n          } while (--tlen);\n\n          sum1 = (sum1 & 0xffff) + (sum1 >>> 16);\n          sum2 = (sum2 & 0xffff) + (sum2 >>> 16);\n        } // add the straggler byte if it exists\n\n\n        if (len & 1) {\n          sum2 += sum1 += input[i] << 8;\n        } // second reduction step to reduce sums to 16 bits\n\n\n        sum1 = (sum1 & 0xffff) + (sum1 >>> 16);\n        sum2 = (sum2 & 0xffff) + (sum2 >>> 16);\n        return (sum2 << 16 | sum1) >>> 0;\n      },\n      readHeaderInfo: function (input, data) {\n        var ptr = data.ptr;\n        var fileIdView = new Uint8Array(input, ptr, 6);\n        var headerInfo = {};\n        headerInfo.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\n\n        if (headerInfo.fileIdentifierString.lastIndexOf(\"Lerc2\", 0) !== 0) {\n          throw \"Unexpected file identifier string (expect Lerc2 ): \" + headerInfo.fileIdentifierString;\n        }\n\n        ptr += 6;\n        var view = new DataView(input, ptr, 8);\n        var fileVersion = view.getInt32(0, true);\n        headerInfo.fileVersion = fileVersion;\n        ptr += 4;\n\n        if (fileVersion >= 3) {\n          headerInfo.checksum = view.getUint32(4, true); //nrows\n\n          ptr += 4;\n        } //keys start from here\n\n\n        view = new DataView(input, ptr, 12);\n        headerInfo.height = view.getUint32(0, true); //nrows\n\n        headerInfo.width = view.getUint32(4, true); //ncols\n\n        ptr += 8;\n\n        if (fileVersion >= 4) {\n          headerInfo.numDims = view.getUint32(8, true);\n          ptr += 4;\n        } else {\n          headerInfo.numDims = 1;\n        }\n\n        view = new DataView(input, ptr, 40);\n        headerInfo.numValidPixel = view.getUint32(0, true);\n        headerInfo.microBlockSize = view.getInt32(4, true);\n        headerInfo.blobSize = view.getInt32(8, true);\n        headerInfo.imageType = view.getInt32(12, true);\n        headerInfo.maxZError = view.getFloat64(16, true);\n        headerInfo.zMin = view.getFloat64(24, true);\n        headerInfo.zMax = view.getFloat64(32, true);\n        ptr += 40;\n        data.headerInfo = headerInfo;\n        data.ptr = ptr;\n        var checksum, keyLength;\n\n        if (fileVersion >= 3) {\n          keyLength = fileVersion >= 4 ? 52 : 48;\n          checksum = this.computeChecksumFletcher32(new Uint8Array(input, ptr - keyLength, headerInfo.blobSize - 14));\n\n          if (checksum !== headerInfo.checksum) {\n            throw \"Checksum failed.\";\n          }\n        }\n\n        return true;\n      },\n      checkMinMaxRanges: function (input, data) {\n        var headerInfo = data.headerInfo;\n        var OutPixelTypeArray = this.getDataTypeArray(headerInfo.imageType);\n        var rangeBytes = headerInfo.numDims * this.getDataTypeSize(headerInfo.imageType);\n        var minValues = this.readSubArray(input, data.ptr, OutPixelTypeArray, rangeBytes);\n        var maxValues = this.readSubArray(input, data.ptr + rangeBytes, OutPixelTypeArray, rangeBytes);\n        data.ptr += 2 * rangeBytes;\n        var i,\n            equal = true;\n\n        for (i = 0; i < headerInfo.numDims; i++) {\n          if (minValues[i] !== maxValues[i]) {\n            equal = false;\n            break;\n          }\n        }\n\n        headerInfo.minValues = minValues;\n        headerInfo.maxValues = maxValues;\n        return equal;\n      },\n      readSubArray: function (input, ptr, OutPixelTypeArray, numBytes) {\n        var rawData;\n\n        if (OutPixelTypeArray === Uint8Array) {\n          rawData = new Uint8Array(input, ptr, numBytes);\n        } else {\n          var arrayBuf = new ArrayBuffer(numBytes);\n          var store8 = new Uint8Array(arrayBuf);\n          store8.set(new Uint8Array(input, ptr, numBytes));\n          rawData = new OutPixelTypeArray(arrayBuf);\n        }\n\n        return rawData;\n      },\n      readMask: function (input, data) {\n        var ptr = data.ptr;\n        var headerInfo = data.headerInfo;\n        var numPixels = headerInfo.width * headerInfo.height;\n        var numValidPixel = headerInfo.numValidPixel;\n        var view = new DataView(input, ptr, 4);\n        var mask = {};\n        mask.numBytes = view.getUint32(0, true);\n        ptr += 4; // Mask Data\n\n        if ((0 === numValidPixel || numPixels === numValidPixel) && 0 !== mask.numBytes) {\n          throw \"invalid mask\";\n        }\n\n        var bitset, resultMask;\n\n        if (numValidPixel === 0) {\n          bitset = new Uint8Array(Math.ceil(numPixels / 8));\n          mask.bitset = bitset;\n          resultMask = new Uint8Array(numPixels);\n          data.pixels.resultMask = resultMask;\n          ptr += mask.numBytes;\n        } // ????? else if (data.mask.numBytes > 0 && data.mask.numBytes< data.numValidPixel) {\n        else if (mask.numBytes > 0) {\n          bitset = new Uint8Array(Math.ceil(numPixels / 8));\n          view = new DataView(input, ptr, mask.numBytes);\n          var cnt = view.getInt16(0, true);\n          var ip = 2,\n              op = 0,\n              val = 0;\n\n          do {\n            if (cnt > 0) {\n              while (cnt--) {\n                bitset[op++] = view.getUint8(ip++);\n              }\n            } else {\n              val = view.getUint8(ip++);\n              cnt = -cnt;\n\n              while (cnt--) {\n                bitset[op++] = val;\n              }\n            }\n\n            cnt = view.getInt16(ip, true);\n            ip += 2;\n          } while (ip < mask.numBytes);\n\n          if (cnt !== -32768 || op < bitset.length) {\n            throw \"Unexpected end of mask RLE encoding\";\n          }\n\n          resultMask = new Uint8Array(numPixels);\n          var mb = 0,\n              k = 0;\n\n          for (k = 0; k < numPixels; k++) {\n            if (k & 7) {\n              mb = bitset[k >> 3];\n              mb <<= k & 7;\n            } else {\n              mb = bitset[k >> 3];\n            }\n\n            if (mb & 128) {\n              resultMask[k] = 1;\n            }\n          }\n\n          data.pixels.resultMask = resultMask;\n          mask.bitset = bitset;\n          ptr += mask.numBytes;\n        }\n\n        data.ptr = ptr;\n        data.mask = mask;\n        return true;\n      },\n      readDataOneSweep: function (input, data, OutPixelTypeArray, useBSQForOutputDim) {\n        var ptr = data.ptr;\n        var headerInfo = data.headerInfo;\n        var numDims = headerInfo.numDims;\n        var numPixels = headerInfo.width * headerInfo.height;\n        var imageType = headerInfo.imageType;\n        var numBytes = headerInfo.numValidPixel * Lerc2Helpers.getDataTypeSize(imageType) * numDims; //data.pixels.numBytes = numBytes;\n\n        var rawData;\n        var mask = data.pixels.resultMask;\n\n        if (OutPixelTypeArray === Uint8Array) {\n          rawData = new Uint8Array(input, ptr, numBytes);\n        } else {\n          var arrayBuf = new ArrayBuffer(numBytes);\n          var store8 = new Uint8Array(arrayBuf);\n          store8.set(new Uint8Array(input, ptr, numBytes));\n          rawData = new OutPixelTypeArray(arrayBuf);\n        }\n\n        if (rawData.length === numPixels * numDims) {\n          if (useBSQForOutputDim) {\n            data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(rawData, numPixels, numDims, OutPixelTypeArray, true);\n          } else {\n            data.pixels.resultPixels = rawData;\n          }\n        } else //mask\n          {\n            data.pixels.resultPixels = new OutPixelTypeArray(numPixels * numDims);\n            var z = 0,\n                k = 0,\n                i = 0,\n                nStart = 0;\n\n            if (numDims > 1) {\n              if (useBSQForOutputDim) {\n                for (k = 0; k < numPixels; k++) {\n                  if (mask[k]) {\n                    nStart = k;\n\n                    for (i = 0; i < numDims; i++, nStart += numPixels) {\n                      data.pixels.resultPixels[nStart] = rawData[z++];\n                    }\n                  }\n                }\n              } else {\n                for (k = 0; k < numPixels; k++) {\n                  if (mask[k]) {\n                    nStart = k * numDims;\n\n                    for (i = 0; i < numDims; i++) {\n                      data.pixels.resultPixels[nStart + i] = rawData[z++];\n                    }\n                  }\n                }\n              }\n            } else {\n              for (k = 0; k < numPixels; k++) {\n                if (mask[k]) {\n                  data.pixels.resultPixels[k] = rawData[z++];\n                }\n              }\n            }\n          }\n\n        ptr += numBytes;\n        data.ptr = ptr; //return data;\n\n        return true;\n      },\n      readHuffmanTree: function (input, data) {\n        var BITS_MAX = this.HUFFMAN_LUT_BITS_MAX; //8 is slow for the large test image\n        //var size_max = 1 << BITS_MAX;\n\n        /* ************************\n        * reading code table\n        *************************/\n\n        var view = new DataView(input, data.ptr, 16);\n        data.ptr += 16;\n        var version = view.getInt32(0, true);\n\n        if (version < 2) {\n          throw \"unsupported Huffman version\";\n        }\n\n        var size = view.getInt32(4, true);\n        var i0 = view.getInt32(8, true);\n        var i1 = view.getInt32(12, true);\n\n        if (i0 >= i1) {\n          return false;\n        }\n\n        var blockDataBuffer = new Uint32Array(i1 - i0);\n        Lerc2Helpers.decodeBits(input, data, blockDataBuffer);\n        var codeTable = []; //size\n\n        var i, j, k, len;\n\n        for (i = i0; i < i1; i++) {\n          j = i - (i < size ? 0 : size); //wrap around\n\n          codeTable[j] = {\n            first: blockDataBuffer[i - i0],\n            second: null\n          };\n        }\n\n        var dataBytes = input.byteLength - data.ptr;\n        var dataWords = Math.ceil(dataBytes / 4);\n        var arrayBuf = new ArrayBuffer(dataWords * 4);\n        var store8 = new Uint8Array(arrayBuf);\n        store8.set(new Uint8Array(input, data.ptr, dataBytes));\n        var stuffedData = new Uint32Array(arrayBuf); //must start from x*4\n\n        var bitPos = 0,\n            word,\n            srcPtr = 0;\n        word = stuffedData[0];\n\n        for (i = i0; i < i1; i++) {\n          j = i - (i < size ? 0 : size); //wrap around\n\n          len = codeTable[j].first;\n\n          if (len > 0) {\n            codeTable[j].second = word << bitPos >>> 32 - len;\n\n            if (32 - bitPos >= len) {\n              bitPos += len;\n\n              if (bitPos === 32) {\n                bitPos = 0;\n                srcPtr++;\n                word = stuffedData[srcPtr];\n              }\n            } else {\n              bitPos += len - 32;\n              srcPtr++;\n              word = stuffedData[srcPtr];\n              codeTable[j].second |= word >>> 32 - bitPos;\n            }\n          }\n        } //finished reading code table\n\n        /* ************************\n        * building lut\n        *************************/\n\n\n        var numBitsLUT = 0,\n            numBitsLUTQick = 0;\n        var tree = new TreeNode();\n\n        for (i = 0; i < codeTable.length; i++) {\n          if (codeTable[i] !== undefined) {\n            numBitsLUT = Math.max(numBitsLUT, codeTable[i].first);\n          }\n        }\n\n        if (numBitsLUT >= BITS_MAX) {\n          numBitsLUTQick = BITS_MAX;\n        } else {\n          numBitsLUTQick = numBitsLUT;\n        } // for debugging purpose\n        // if (numBitsLUT >= 30) {\n        //   console.log(\"WARning, large NUM LUT BITS IS \" + numBitsLUT);\n        // }\n\n\n        var decodeLut = [],\n            entry,\n            code,\n            numEntries,\n            jj,\n            currentBit,\n            node;\n\n        for (i = i0; i < i1; i++) {\n          j = i - (i < size ? 0 : size); //wrap around\n\n          len = codeTable[j].first;\n\n          if (len > 0) {\n            entry = [len, j];\n\n            if (len <= numBitsLUTQick) {\n              code = codeTable[j].second << numBitsLUTQick - len;\n              numEntries = 1 << numBitsLUTQick - len;\n\n              for (k = 0; k < numEntries; k++) {\n                decodeLut[code | k] = entry;\n              }\n            } else {\n              //build tree\n              code = codeTable[j].second;\n              node = tree;\n\n              for (jj = len - 1; jj >= 0; jj--) {\n                currentBit = code >>> jj & 1; //no left shift as length could be 30,31\n\n                if (currentBit) {\n                  if (!node.right) {\n                    node.right = new TreeNode();\n                  }\n\n                  node = node.right;\n                } else {\n                  if (!node.left) {\n                    node.left = new TreeNode();\n                  }\n\n                  node = node.left;\n                }\n\n                if (jj === 0 && !node.val) {\n                  node.val = entry[1];\n                }\n              }\n            }\n          }\n        }\n\n        return {\n          decodeLut: decodeLut,\n          numBitsLUTQick: numBitsLUTQick,\n          numBitsLUT: numBitsLUT,\n          tree: tree,\n          stuffedData: stuffedData,\n          srcPtr: srcPtr,\n          bitPos: bitPos\n        };\n      },\n      readHuffman: function (input, data, OutPixelTypeArray, useBSQForOutputDim) {\n        var headerInfo = data.headerInfo;\n        var numDims = headerInfo.numDims;\n        var height = data.headerInfo.height;\n        var width = data.headerInfo.width;\n        var numPixels = width * height; //var size_max = 1 << BITS_MAX;\n\n        /* ************************\n        * reading huffman structure info\n        *************************/\n\n        var huffmanInfo = this.readHuffmanTree(input, data);\n        var decodeLut = huffmanInfo.decodeLut;\n        var tree = huffmanInfo.tree; //stuffedData includes huffman headers\n\n        var stuffedData = huffmanInfo.stuffedData;\n        var srcPtr = huffmanInfo.srcPtr;\n        var bitPos = huffmanInfo.bitPos;\n        var numBitsLUTQick = huffmanInfo.numBitsLUTQick;\n        var numBitsLUT = huffmanInfo.numBitsLUT;\n        var offset = data.headerInfo.imageType === 0 ? 128 : 0;\n        /*************************\n        *  decode\n        ***************************/\n\n        var node,\n            val,\n            delta,\n            mask = data.pixels.resultMask,\n            valTmp,\n            valTmpQuick,\n            currentBit;\n        var i, j, k, ii;\n        var prevVal = 0;\n\n        if (bitPos > 0) {\n          srcPtr++;\n          bitPos = 0;\n        }\n\n        var word = stuffedData[srcPtr];\n        var deltaEncode = data.encodeMode === 1;\n        var resultPixelsAllDim = new OutPixelTypeArray(numPixels * numDims);\n        var resultPixels = resultPixelsAllDim;\n        var iDim; // TODO: reevaluate the need to keep inlined decoding code as IE support is phasing out\n\n        if (numDims < 2 || deltaEncode) {\n          for (iDim = 0; iDim < numDims; iDim++) {\n            if (numDims > 1) {\n              //get the mem block of current dimension\n              resultPixels = new OutPixelTypeArray(resultPixelsAllDim.buffer, numPixels * iDim, numPixels);\n              prevVal = 0;\n            }\n\n            if (data.headerInfo.numValidPixel === width * height) {\n              //all valid\n              for (k = 0, i = 0; i < height; i++) {\n                for (j = 0; j < width; j++, k++) {\n                  val = 0;\n                  valTmp = word << bitPos >>> 32 - numBitsLUTQick;\n                  valTmpQuick = valTmp; // >>> deltaBits;\n\n                  if (32 - bitPos < numBitsLUTQick) {\n                    valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUTQick;\n                    valTmpQuick = valTmp; // >>> deltaBits;\n                  }\n\n                  if (decodeLut[valTmpQuick]) // if there, move the correct number of bits and done\n                    {\n                      val = decodeLut[valTmpQuick][1];\n                      bitPos += decodeLut[valTmpQuick][0];\n                    } else {\n                    valTmp = word << bitPos >>> 32 - numBitsLUT;\n                    valTmpQuick = valTmp; // >>> deltaBits;\n\n                    if (32 - bitPos < numBitsLUT) {\n                      valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUT;\n                      valTmpQuick = valTmp; // >>> deltaBits;\n                    }\n\n                    node = tree;\n\n                    for (ii = 0; ii < numBitsLUT; ii++) {\n                      currentBit = valTmp >>> numBitsLUT - ii - 1 & 1;\n                      node = currentBit ? node.right : node.left;\n\n                      if (!(node.left || node.right)) {\n                        val = node.val;\n                        bitPos = bitPos + ii + 1;\n                        break;\n                      }\n                    }\n                  }\n\n                  if (bitPos >= 32) {\n                    bitPos -= 32;\n                    srcPtr++;\n                    word = stuffedData[srcPtr];\n                  }\n\n                  delta = val - offset;\n\n                  if (deltaEncode) {\n                    if (j > 0) {\n                      delta += prevVal; // use overflow\n                    } else if (i > 0) {\n                      delta += resultPixels[k - width];\n                    } else {\n                      delta += prevVal;\n                    }\n\n                    delta &= 0xFF; //overflow\n\n                    resultPixels[k] = delta; //overflow\n\n                    prevVal = delta;\n                  } else {\n                    resultPixels[k] = delta;\n                  }\n                }\n              }\n            } else {\n              //not all valid, use mask\n              for (k = 0, i = 0; i < height; i++) {\n                for (j = 0; j < width; j++, k++) {\n                  if (mask[k]) {\n                    val = 0;\n                    valTmp = word << bitPos >>> 32 - numBitsLUTQick;\n                    valTmpQuick = valTmp; // >>> deltaBits;\n\n                    if (32 - bitPos < numBitsLUTQick) {\n                      valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUTQick;\n                      valTmpQuick = valTmp; // >>> deltaBits;\n                    }\n\n                    if (decodeLut[valTmpQuick]) // if there, move the correct number of bits and done\n                      {\n                        val = decodeLut[valTmpQuick][1];\n                        bitPos += decodeLut[valTmpQuick][0];\n                      } else {\n                      valTmp = word << bitPos >>> 32 - numBitsLUT;\n                      valTmpQuick = valTmp; // >>> deltaBits;\n\n                      if (32 - bitPos < numBitsLUT) {\n                        valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUT;\n                        valTmpQuick = valTmp; // >>> deltaBits;\n                      }\n\n                      node = tree;\n\n                      for (ii = 0; ii < numBitsLUT; ii++) {\n                        currentBit = valTmp >>> numBitsLUT - ii - 1 & 1;\n                        node = currentBit ? node.right : node.left;\n\n                        if (!(node.left || node.right)) {\n                          val = node.val;\n                          bitPos = bitPos + ii + 1;\n                          break;\n                        }\n                      }\n                    }\n\n                    if (bitPos >= 32) {\n                      bitPos -= 32;\n                      srcPtr++;\n                      word = stuffedData[srcPtr];\n                    }\n\n                    delta = val - offset;\n\n                    if (deltaEncode) {\n                      if (j > 0 && mask[k - 1]) {\n                        delta += prevVal; // use overflow\n                      } else if (i > 0 && mask[k - width]) {\n                        delta += resultPixels[k - width];\n                      } else {\n                        delta += prevVal;\n                      }\n\n                      delta &= 0xFF; //overflow\n\n                      resultPixels[k] = delta; //overflow\n\n                      prevVal = delta;\n                    } else {\n                      resultPixels[k] = delta;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          for (k = 0, i = 0; i < height; i++) {\n            for (j = 0; j < width; j++) {\n              k = i * width + j;\n\n              if (!mask || mask[k]) {\n                for (iDim = 0; iDim < numDims; iDim++, k += numPixels) {\n                  val = 0;\n                  valTmp = word << bitPos >>> 32 - numBitsLUTQick;\n                  valTmpQuick = valTmp;\n\n                  if (32 - bitPos < numBitsLUTQick) {\n                    valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUTQick;\n                    valTmpQuick = valTmp;\n                  }\n\n                  if (decodeLut[valTmpQuick]) {\n                    val = decodeLut[valTmpQuick][1];\n                    bitPos += decodeLut[valTmpQuick][0];\n                  } else {\n                    valTmp = word << bitPos >>> 32 - numBitsLUT;\n                    valTmpQuick = valTmp;\n\n                    if (32 - bitPos < numBitsLUT) {\n                      valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUT;\n                      valTmpQuick = valTmp;\n                    }\n\n                    node = tree;\n\n                    for (ii = 0; ii < numBitsLUT; ii++) {\n                      currentBit = valTmp >>> numBitsLUT - ii - 1 & 1;\n                      node = currentBit ? node.right : node.left;\n\n                      if (!(node.left || node.right)) {\n                        val = node.val;\n                        bitPos = bitPos + ii + 1;\n                        break;\n                      }\n                    }\n                  }\n\n                  if (bitPos >= 32) {\n                    bitPos -= 32;\n                    srcPtr++;\n                    word = stuffedData[srcPtr];\n                  }\n\n                  delta = val - offset;\n                  resultPixels[k] = delta;\n                }\n              }\n            }\n          }\n        }\n\n        data.ptr = data.ptr + (srcPtr + 1) * 4 + (bitPos > 0 ? 4 : 0);\n        data.pixels.resultPixels = resultPixelsAllDim; //swap for BIP layout\n\n        if (numDims > 1 && !useBSQForOutputDim) {\n          data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(resultPixelsAllDim, numPixels, numDims, OutPixelTypeArray);\n        }\n      },\n      decodeBits: function (input, data, blockDataBuffer, offset, iDim) {\n        {\n          //bitstuff encoding is 3\n          var headerInfo = data.headerInfo;\n          var fileVersion = headerInfo.fileVersion; //var block = {};\n\n          var blockPtr = 0;\n          var viewByteLength = input.byteLength - data.ptr >= 5 ? 5 : input.byteLength - data.ptr;\n          var view = new DataView(input, data.ptr, viewByteLength);\n          var headerByte = view.getUint8(0);\n          blockPtr++;\n          var bits67 = headerByte >> 6;\n          var n = bits67 === 0 ? 4 : 3 - bits67;\n          var doLut = (headerByte & 32) > 0 ? true : false; //5th bit\n\n          var numBits = headerByte & 31;\n          var numElements = 0;\n\n          if (n === 1) {\n            numElements = view.getUint8(blockPtr);\n            blockPtr++;\n          } else if (n === 2) {\n            numElements = view.getUint16(blockPtr, true);\n            blockPtr += 2;\n          } else if (n === 4) {\n            numElements = view.getUint32(blockPtr, true);\n            blockPtr += 4;\n          } else {\n            throw \"Invalid valid pixel count type\";\n          } //fix: huffman codes are bit stuffed, but not bound by data's max value, so need to use originalUnstuff\n          //offset = offset || 0;\n\n\n          var scale = 2 * headerInfo.maxZError;\n          var stuffedData, arrayBuf, store8, dataBytes, dataWords;\n          var lutArr, lutData, lutBytes, lutBitsPerElement, bitsPerPixel;\n          var zMax = headerInfo.numDims > 1 ? headerInfo.maxValues[iDim] : headerInfo.zMax;\n\n          if (doLut) {\n            data.counter.lut++;\n            lutBytes = view.getUint8(blockPtr);\n            lutBitsPerElement = numBits;\n            blockPtr++;\n            dataBytes = Math.ceil((lutBytes - 1) * numBits / 8);\n            dataWords = Math.ceil(dataBytes / 4);\n            arrayBuf = new ArrayBuffer(dataWords * 4);\n            store8 = new Uint8Array(arrayBuf);\n            data.ptr += blockPtr;\n            store8.set(new Uint8Array(input, data.ptr, dataBytes));\n            lutData = new Uint32Array(arrayBuf);\n            data.ptr += dataBytes;\n            bitsPerPixel = 0;\n\n            while (lutBytes - 1 >>> bitsPerPixel) {\n              bitsPerPixel++;\n            }\n\n            dataBytes = Math.ceil(numElements * bitsPerPixel / 8);\n            dataWords = Math.ceil(dataBytes / 4);\n            arrayBuf = new ArrayBuffer(dataWords * 4);\n            store8 = new Uint8Array(arrayBuf);\n            store8.set(new Uint8Array(input, data.ptr, dataBytes));\n            stuffedData = new Uint32Array(arrayBuf);\n            data.ptr += dataBytes;\n\n            if (fileVersion >= 3) {\n              lutArr = BitStuffer.unstuffLUT2(lutData, numBits, lutBytes - 1, offset, scale, zMax);\n            } else {\n              lutArr = BitStuffer.unstuffLUT(lutData, numBits, lutBytes - 1, offset, scale, zMax);\n            } //lutArr.unshift(0);\n\n\n            if (fileVersion >= 3) {\n              //BitStuffer.unstuff2(block, blockDataBuffer, headerInfo.zMax);\n              BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);\n            } else {\n              BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);\n            }\n          } else {\n            //console.debug(\"bitstuffer\");\n            data.counter.bitstuffer++;\n            bitsPerPixel = numBits;\n            data.ptr += blockPtr;\n\n            if (bitsPerPixel > 0) {\n              dataBytes = Math.ceil(numElements * bitsPerPixel / 8);\n              dataWords = Math.ceil(dataBytes / 4);\n              arrayBuf = new ArrayBuffer(dataWords * 4);\n              store8 = new Uint8Array(arrayBuf);\n              store8.set(new Uint8Array(input, data.ptr, dataBytes));\n              stuffedData = new Uint32Array(arrayBuf);\n              data.ptr += dataBytes;\n\n              if (fileVersion >= 3) {\n                if (offset == null) {\n                  BitStuffer.originalUnstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements);\n                } else {\n                  BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);\n                }\n              } else {\n                if (offset == null) {\n                  BitStuffer.originalUnstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements);\n                } else {\n                  BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);\n                }\n              }\n            }\n          }\n        }\n      },\n      readTiles: function (input, data, OutPixelTypeArray, useBSQForOutputDim) {\n        var headerInfo = data.headerInfo;\n        var width = headerInfo.width;\n        var height = headerInfo.height;\n        var numPixels = width * height;\n        var microBlockSize = headerInfo.microBlockSize;\n        var imageType = headerInfo.imageType;\n        var dataTypeSize = Lerc2Helpers.getDataTypeSize(imageType);\n        var numBlocksX = Math.ceil(width / microBlockSize);\n        var numBlocksY = Math.ceil(height / microBlockSize);\n        data.pixels.numBlocksY = numBlocksY;\n        data.pixels.numBlocksX = numBlocksX;\n        data.pixels.ptr = 0;\n        var row = 0,\n            col = 0,\n            blockY = 0,\n            blockX = 0,\n            thisBlockHeight = 0,\n            thisBlockWidth = 0,\n            bytesLeft = 0,\n            headerByte = 0,\n            bits67 = 0,\n            testCode = 0,\n            outPtr = 0,\n            outStride = 0,\n            numBytes = 0,\n            bytesleft = 0,\n            z = 0,\n            blockPtr = 0;\n        var view, block, arrayBuf, store8, rawData;\n        var blockEncoding;\n        var blockDataBuffer = new OutPixelTypeArray(microBlockSize * microBlockSize);\n        var lastBlockHeight = height % microBlockSize || microBlockSize;\n        var lastBlockWidth = width % microBlockSize || microBlockSize;\n        var offsetType, offset;\n        var numDims = headerInfo.numDims,\n            iDim;\n        var mask = data.pixels.resultMask;\n        var resultPixels = data.pixels.resultPixels;\n        var fileVersion = headerInfo.fileVersion;\n        var fileVersionCheckNum = fileVersion >= 5 ? 14 : 15;\n        var isDiffEncoding;\n        var zMax = headerInfo.zMax; //var resultPixelsAllDim = resultPixels;\n\n        var resultPixelsPrevDim;\n\n        for (blockY = 0; blockY < numBlocksY; blockY++) {\n          thisBlockHeight = blockY !== numBlocksY - 1 ? microBlockSize : lastBlockHeight;\n\n          for (blockX = 0; blockX < numBlocksX; blockX++) {\n            //console.debug(\"y\" + blockY + \" x\" + blockX);\n            thisBlockWidth = blockX !== numBlocksX - 1 ? microBlockSize : lastBlockWidth;\n            outPtr = blockY * width * microBlockSize + blockX * microBlockSize;\n            outStride = width - thisBlockWidth;\n\n            for (iDim = 0; iDim < numDims; iDim++) {\n              if (numDims > 1) {\n                resultPixelsPrevDim = resultPixels;\n                outPtr = blockY * width * microBlockSize + blockX * microBlockSize;\n                resultPixels = new OutPixelTypeArray(data.pixels.resultPixels.buffer, numPixels * iDim * dataTypeSize, numPixels);\n                zMax = headerInfo.maxValues[iDim];\n              } else {\n                resultPixelsPrevDim = null;\n              }\n\n              bytesLeft = input.byteLength - data.ptr;\n              view = new DataView(input, data.ptr, Math.min(10, bytesLeft));\n              block = {};\n              blockPtr = 0;\n              headerByte = view.getUint8(0);\n              blockPtr++;\n              isDiffEncoding = headerInfo.fileVersion >= 5 ? headerByte & 4 : 0;\n              bits67 = headerByte >> 6 & 0xFF;\n              testCode = headerByte >> 2 & fileVersionCheckNum; // use bits 2345 for integrity check\n\n              if (testCode !== (blockX * microBlockSize >> 3 & fileVersionCheckNum)) {\n                throw \"integrity issue\";\n              }\n\n              if (isDiffEncoding && iDim === 0) {\n                throw \"integrity issue\";\n              }\n\n              blockEncoding = headerByte & 3;\n\n              if (blockEncoding > 3) {\n                data.ptr += blockPtr;\n                throw \"Invalid block encoding (\" + blockEncoding + \")\";\n              } else if (blockEncoding === 2) {\n                //constant 0\n                if (isDiffEncoding) {\n                  if (mask) {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        if (mask[outPtr]) {\n                          resultPixels[outPtr] = resultPixelsPrevDim[outPtr];\n                        }\n\n                        outPtr++;\n                      }\n                    }\n                  } else {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        resultPixels[outPtr] = resultPixelsPrevDim[outPtr];\n                        outPtr++;\n                      }\n                    }\n                  }\n                }\n\n                data.counter.constant++;\n                data.ptr += blockPtr;\n                continue;\n              } else if (blockEncoding === 0) {\n                //uncompressed\n                if (isDiffEncoding) {\n                  // doesn't make sense, should not happen\n                  throw \"integrity issue\";\n                }\n\n                data.counter.uncompressed++;\n                data.ptr += blockPtr;\n                numBytes = thisBlockHeight * thisBlockWidth * dataTypeSize;\n                bytesleft = input.byteLength - data.ptr;\n                numBytes = numBytes < bytesleft ? numBytes : bytesleft; //bit alignment\n\n                arrayBuf = new ArrayBuffer(numBytes % dataTypeSize === 0 ? numBytes : numBytes + dataTypeSize - numBytes % dataTypeSize);\n                store8 = new Uint8Array(arrayBuf);\n                store8.set(new Uint8Array(input, data.ptr, numBytes));\n                rawData = new OutPixelTypeArray(arrayBuf);\n                z = 0;\n\n                if (mask) {\n                  for (row = 0; row < thisBlockHeight; row++) {\n                    for (col = 0; col < thisBlockWidth; col++) {\n                      if (mask[outPtr]) {\n                        resultPixels[outPtr] = rawData[z++];\n                      }\n\n                      outPtr++;\n                    }\n\n                    outPtr += outStride;\n                  }\n                } else {\n                  //all valid\n                  for (row = 0; row < thisBlockHeight; row++) {\n                    for (col = 0; col < thisBlockWidth; col++) {\n                      resultPixels[outPtr++] = rawData[z++];\n                    }\n\n                    outPtr += outStride;\n                  }\n                }\n\n                data.ptr += z * dataTypeSize;\n              } else {\n                //1 or 3\n                offsetType = Lerc2Helpers.getDataTypeUsed(isDiffEncoding && imageType < 6 ? 4 : imageType, bits67);\n                offset = Lerc2Helpers.getOnePixel(block, blockPtr, offsetType, view);\n                blockPtr += Lerc2Helpers.getDataTypeSize(offsetType);\n\n                if (blockEncoding === 3) //constant offset value\n                  {\n                    data.ptr += blockPtr;\n                    data.counter.constantoffset++; //you can delete the following resultMask case in favor of performance because val is constant and users use nodata mask, otherwise nodatavalue post processing handles it too.\n                    //while the above statement is true, we're not doing it as we want to keep invalid pixel value at 0 rather than arbitrary values\n\n                    if (mask) {\n                      for (row = 0; row < thisBlockHeight; row++) {\n                        for (col = 0; col < thisBlockWidth; col++) {\n                          if (mask[outPtr]) {\n                            resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset) : offset;\n                          }\n\n                          outPtr++;\n                        }\n\n                        outPtr += outStride;\n                      }\n                    } else {\n                      for (row = 0; row < thisBlockHeight; row++) {\n                        for (col = 0; col < thisBlockWidth; col++) {\n                          resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset) : offset;\n                          outPtr++;\n                        }\n\n                        outPtr += outStride;\n                      }\n                    }\n                  } else {\n                  //bitstuff encoding is 3\n                  data.ptr += blockPtr; //heavy lifting\n\n                  Lerc2Helpers.decodeBits(input, data, blockDataBuffer, offset, iDim);\n                  blockPtr = 0; // duplicate code to favor performance, diff encoding is for multidimension only\n\n                  if (isDiffEncoding) {\n                    if (mask) {\n                      for (row = 0; row < thisBlockHeight; row++) {\n                        for (col = 0; col < thisBlockWidth; col++) {\n                          if (mask[outPtr]) {\n                            resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];\n                          }\n\n                          outPtr++;\n                        }\n\n                        outPtr += outStride;\n                      }\n                    } else {\n                      for (row = 0; row < thisBlockHeight; row++) {\n                        for (col = 0; col < thisBlockWidth; col++) {\n                          resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];\n                          outPtr++;\n                        }\n\n                        outPtr += outStride;\n                      }\n                    }\n                  } else if (mask) {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        if (mask[outPtr]) {\n                          resultPixels[outPtr] = blockDataBuffer[blockPtr++];\n                        }\n\n                        outPtr++;\n                      }\n\n                      outPtr += outStride;\n                    }\n                  } else {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        resultPixels[outPtr++] = blockDataBuffer[blockPtr++];\n                      }\n\n                      outPtr += outStride;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } //swap for BIP: it's always easier for clients to handle BSQ so we keep existing logic and introduce a swap here to minimze changes\n\n\n        if (numDims > 1 && !useBSQForOutputDim) {\n          data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(data.pixels.resultPixels, numPixels, numDims, OutPixelTypeArray);\n        }\n      },\n\n      /*****************\n      *  private methods (helper methods)\n      *****************/\n      formatFileInfo: function (data) {\n        return {\n          \"fileIdentifierString\": data.headerInfo.fileIdentifierString,\n          \"fileVersion\": data.headerInfo.fileVersion,\n          \"imageType\": data.headerInfo.imageType,\n          \"height\": data.headerInfo.height,\n          \"width\": data.headerInfo.width,\n          \"numValidPixel\": data.headerInfo.numValidPixel,\n          \"microBlockSize\": data.headerInfo.microBlockSize,\n          \"blobSize\": data.headerInfo.blobSize,\n          \"maxZError\": data.headerInfo.maxZError,\n          \"pixelType\": Lerc2Helpers.getPixelType(data.headerInfo.imageType),\n          \"eofOffset\": data.eofOffset,\n          \"mask\": data.mask ? {\n            \"numBytes\": data.mask.numBytes\n          } : null,\n          \"pixels\": {\n            \"numBlocksX\": data.pixels.numBlocksX,\n            \"numBlocksY\": data.pixels.numBlocksY,\n            //\"numBytes\": data.pixels.numBytes,\n            \"maxValue\": data.headerInfo.zMax,\n            \"minValue\": data.headerInfo.zMin,\n            \"noDataValue\": data.noDataValue\n          }\n        };\n      },\n      constructConstantSurface: function (data, useBSQForOutputDim) {\n        var val = data.headerInfo.zMax;\n        var valMin = data.headerInfo.zMin;\n        var maxValues = data.headerInfo.maxValues;\n        var numDims = data.headerInfo.numDims;\n        var numPixels = data.headerInfo.height * data.headerInfo.width;\n        var i = 0,\n            k = 0,\n            nStart = 0;\n        var mask = data.pixels.resultMask;\n        var resultPixels = data.pixels.resultPixels;\n\n        if (mask) {\n          if (numDims > 1) {\n            if (useBSQForOutputDim) {\n              for (i = 0; i < numDims; i++) {\n                nStart = i * numPixels;\n                val = maxValues[i];\n\n                for (k = 0; k < numPixels; k++) {\n                  if (mask[k]) {\n                    resultPixels[nStart + k] = val;\n                  }\n                }\n              }\n            } else {\n              for (k = 0; k < numPixels; k++) {\n                if (mask[k]) {\n                  nStart = k * numDims;\n\n                  for (i = 0; i < numDims; i++) {\n                    resultPixels[nStart + numDims] = maxValues[i];\n                  }\n                }\n              }\n            }\n          } else {\n            for (k = 0; k < numPixels; k++) {\n              if (mask[k]) {\n                resultPixels[k] = val;\n              }\n            }\n          }\n        } else {\n          if (numDims > 1 && valMin !== val) {\n            if (useBSQForOutputDim) {\n              for (i = 0; i < numDims; i++) {\n                nStart = i * numPixels;\n                val = maxValues[i];\n\n                for (k = 0; k < numPixels; k++) {\n                  resultPixels[nStart + k] = val;\n                }\n              }\n            } else {\n              for (k = 0; k < numPixels; k++) {\n                nStart = k * numDims;\n\n                for (i = 0; i < numDims; i++) {\n                  resultPixels[nStart + i] = maxValues[i];\n                }\n              }\n            }\n          } else {\n            for (k = 0; k < numPixels * numDims; k++) {\n              resultPixels[k] = val;\n            }\n          }\n        }\n\n        return;\n      },\n      getDataTypeArray: function (t) {\n        var tp;\n\n        switch (t) {\n          case 0:\n            //char\n            tp = Int8Array;\n            break;\n\n          case 1:\n            //byte\n            tp = Uint8Array;\n            break;\n\n          case 2:\n            //short\n            tp = Int16Array;\n            break;\n\n          case 3:\n            //ushort\n            tp = Uint16Array;\n            break;\n\n          case 4:\n            tp = Int32Array;\n            break;\n\n          case 5:\n            tp = Uint32Array;\n            break;\n\n          case 6:\n            tp = Float32Array;\n            break;\n\n          case 7:\n            tp = Float64Array;\n            break;\n\n          default:\n            tp = Float32Array;\n        }\n\n        return tp;\n      },\n      getPixelType: function (t) {\n        var tp;\n\n        switch (t) {\n          case 0:\n            //char\n            tp = \"S8\";\n            break;\n\n          case 1:\n            //byte\n            tp = \"U8\";\n            break;\n\n          case 2:\n            //short\n            tp = \"S16\";\n            break;\n\n          case 3:\n            //ushort\n            tp = \"U16\";\n            break;\n\n          case 4:\n            tp = \"S32\";\n            break;\n\n          case 5:\n            tp = \"U32\";\n            break;\n\n          case 6:\n            tp = \"F32\";\n            break;\n\n          case 7:\n            tp = \"F64\";\n            break;\n\n          default:\n            tp = \"F32\";\n        }\n\n        return tp;\n      },\n      isValidPixelValue: function (t, val) {\n        if (val == null) {\n          return false;\n        }\n\n        var isValid;\n\n        switch (t) {\n          case 0:\n            //char\n            isValid = val >= -128 && val <= 127;\n            break;\n\n          case 1:\n            //byte  (unsigned char)\n            isValid = val >= 0 && val <= 255;\n            break;\n\n          case 2:\n            //short\n            isValid = val >= -32768 && val <= 32767;\n            break;\n\n          case 3:\n            //ushort\n            isValid = val >= 0 && val <= 65536;\n            break;\n\n          case 4:\n            //int 32\n            isValid = val >= -2147483648 && val <= 2147483647;\n            break;\n\n          case 5:\n            //uinit 32\n            isValid = val >= 0 && val <= 4294967296;\n            break;\n\n          case 6:\n            isValid = val >= -3.4027999387901484e+38 && val <= 3.4027999387901484e+38;\n            break;\n\n          case 7:\n            isValid = val >= -1.7976931348623157e+308 && val <= 1.7976931348623157e+308;\n            break;\n\n          default:\n            isValid = false;\n        }\n\n        return isValid;\n      },\n      getDataTypeSize: function (t) {\n        var s = 0;\n\n        switch (t) {\n          case 0: //ubyte\n\n          case 1:\n            //byte\n            s = 1;\n            break;\n\n          case 2: //short\n\n          case 3:\n            //ushort\n            s = 2;\n            break;\n\n          case 4:\n          case 5:\n          case 6:\n            s = 4;\n            break;\n\n          case 7:\n            s = 8;\n            break;\n\n          default:\n            s = t;\n        }\n\n        return s;\n      },\n      getDataTypeUsed: function (dt, tc) {\n        var t = dt;\n\n        switch (dt) {\n          case 2: //short\n\n          case 4:\n            //long\n            t = dt - tc;\n            break;\n\n          case 3: //ushort\n\n          case 5:\n            //ulong\n            t = dt - 2 * tc;\n            break;\n\n          case 6:\n            //float\n            if (0 === tc) {\n              t = dt;\n            } else if (1 === tc) {\n              t = 2;\n            } else {\n              t = 1; //byte\n            }\n\n            break;\n\n          case 7:\n            //double\n            if (0 === tc) {\n              t = dt;\n            } else {\n              t = dt - 2 * tc + 1;\n            }\n\n            break;\n\n          default:\n            t = dt;\n            break;\n        }\n\n        return t;\n      },\n      getOnePixel: function (block, blockPtr, offsetType, view) {\n        var temp = 0;\n\n        switch (offsetType) {\n          case 0:\n            //char\n            temp = view.getInt8(blockPtr);\n            break;\n\n          case 1:\n            //byte\n            temp = view.getUint8(blockPtr);\n            break;\n\n          case 2:\n            temp = view.getInt16(blockPtr, true);\n            break;\n\n          case 3:\n            temp = view.getUint16(blockPtr, true);\n            break;\n\n          case 4:\n            temp = view.getInt32(blockPtr, true);\n            break;\n\n          case 5:\n            temp = view.getUInt32(blockPtr, true);\n            break;\n\n          case 6:\n            temp = view.getFloat32(blockPtr, true);\n            break;\n\n          case 7:\n            temp = view.getFloat64(blockPtr, true);\n            break;\n\n          default:\n            throw \"the decoder does not understand this pixel type\";\n        }\n\n        return temp;\n      },\n      swapDimensionOrder: function (pixels, numPixels, numDims, OutPixelTypeArray, inputIsBIP) {\n        var i = 0,\n            j = 0,\n            iDim = 0,\n            temp = 0,\n            swap = pixels;\n\n        if (numDims > 1) {\n          swap = new OutPixelTypeArray(numPixels * numDims);\n\n          if (inputIsBIP) {\n            for (i = 0; i < numPixels; i++) {\n              temp = i;\n\n              for (iDim = 0; iDim < numDims; iDim++, temp += numPixels) {\n                swap[temp] = pixels[j++];\n              }\n            }\n          } else {\n            for (i = 0; i < numPixels; i++) {\n              temp = i;\n\n              for (iDim = 0; iDim < numDims; iDim++, temp += numPixels) {\n                swap[j++] = pixels[temp];\n              }\n            }\n          }\n        }\n\n        return swap;\n      }\n    };\n    /***************************************************\n    *private class for a tree node. Huffman code is in Lerc2Helpers\n    ****************************************************/\n\n    var TreeNode = function (val, left, right) {\n      this.val = val;\n      this.left = left;\n      this.right = right;\n    };\n\n    var Lerc2Decode = {\n      /*\n      * ********removed options compared to LERC1. We can bring some of them back if needed.\n       * removed pixel type. LERC2 is typed and doesn't require user to give pixel type\n       * changed encodedMaskData to maskData. LERC2 's js version make it faster to use maskData directly.\n       * removed returnMask. mask is used by LERC2 internally and is cost free. In case of user input mask, it's returned as well and has neglible cost.\n       * removed nodatavalue. Because LERC2 pixels are typed, nodatavalue will sacrify a useful value for many types (8bit, 16bit) etc,\n       *       user has to be knowledgable enough about raster and their data to avoid usability issues. so nodata value is simply removed now.\n       *       We can add it back later if their's a clear requirement.\n       * removed encodedMask. This option was not implemented in LercDecode. It can be done after decoding (less efficient)\n       * removed computeUsedBitDepths.\n       *\n       *\n       * response changes compared to LERC1\n       * 1. encodedMaskData is not available\n       * 2. noDataValue is optional (returns only if user's noDataValue is with in the valid data type range)\n       * 3. maskData is always available\n      */\n\n      /*****************\n      *  public properties\n      ******************/\n      //HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, not configurable\n\n      /*****************\n      *  public methods\n      *****************/\n\n      /**\n       * Decode a LERC2 byte stream and return an object containing the pixel data and optional metadata.\n       *\n       * @param {ArrayBuffer} input The LERC input byte stream\n       * @param {object} [options] options Decoding options\n       * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid LERC file is expected at that position\n       * @param {boolean} [options.returnFileInfo] If true, the return value will have a fileInfo property that contains metadata obtained from the LERC headers and the decoding process\n       * @param {boolean} [options.returnPixelInterleavedDims]  If true, returned dimensions are pixel-interleaved, a.k.a [p1_dim0, p1_dim1, p1_dimn, p2_dim0...], default is [p1_dim0, p2_dim0, ..., p1_dim1, p2_dim1...]\n       */\n      decode: function (\n      /*byte array*/\n      input,\n      /*object*/\n      options) {\n        //currently there's a bug in the sparse array, so please do not set to false\n        options = options || {};\n        var noDataValue = options.noDataValue; //initialize\n\n        var i = 0,\n            data = {};\n        data.ptr = options.inputOffset || 0;\n        data.pixels = {}; // File header\n\n        if (!Lerc2Helpers.readHeaderInfo(input, data)) {\n          return;\n        }\n\n        var headerInfo = data.headerInfo;\n        var fileVersion = headerInfo.fileVersion;\n        var OutPixelTypeArray = Lerc2Helpers.getDataTypeArray(headerInfo.imageType); // version check\n\n        if (fileVersion > 5) {\n          throw \"unsupported lerc version 2.\" + fileVersion;\n        } // Mask Header\n\n\n        Lerc2Helpers.readMask(input, data);\n\n        if (headerInfo.numValidPixel !== headerInfo.width * headerInfo.height && !data.pixels.resultMask) {\n          data.pixels.resultMask = options.maskData;\n        }\n\n        var numPixels = headerInfo.width * headerInfo.height;\n        data.pixels.resultPixels = new OutPixelTypeArray(numPixels * headerInfo.numDims);\n        data.counter = {\n          onesweep: 0,\n          uncompressed: 0,\n          lut: 0,\n          bitstuffer: 0,\n          constant: 0,\n          constantoffset: 0\n        };\n        var useBSQForOutputDim = !options.returnPixelInterleavedDims;\n\n        if (headerInfo.numValidPixel !== 0) {\n          //not tested\n          if (headerInfo.zMax === headerInfo.zMin) //constant surface\n            {\n              Lerc2Helpers.constructConstantSurface(data, useBSQForOutputDim);\n            } else if (fileVersion >= 4 && Lerc2Helpers.checkMinMaxRanges(input, data)) {\n            Lerc2Helpers.constructConstantSurface(data, useBSQForOutputDim);\n          } else {\n            var view = new DataView(input, data.ptr, 2);\n            var bReadDataOneSweep = view.getUint8(0);\n            data.ptr++;\n\n            if (bReadDataOneSweep) {\n              //console.debug(\"OneSweep\");\n              Lerc2Helpers.readDataOneSweep(input, data, OutPixelTypeArray, useBSQForOutputDim);\n            } else {\n              //lerc2.1: //bitstuffing + lut\n              //lerc2.2: //bitstuffing + lut + huffman\n              //lerc2.3: new bitstuffer\n              if (fileVersion > 1 && headerInfo.imageType <= 1 && Math.abs(headerInfo.maxZError - 0.5) < 0.00001) {\n                //this is 2.x plus 8 bit (unsigned and signed) data, possiblity of Huffman\n                var flagHuffman = view.getUint8(1);\n                data.ptr++;\n                data.encodeMode = flagHuffman;\n\n                if (flagHuffman > 2 || fileVersion < 4 && flagHuffman > 1) {\n                  throw \"Invalid Huffman flag \" + flagHuffman;\n                }\n\n                if (flagHuffman) {\n                  //1 - delta Huffman, 2 - Huffman\n                  //console.log(\"Huffman\");\n                  Lerc2Helpers.readHuffman(input, data, OutPixelTypeArray, useBSQForOutputDim);\n                } else {\n                  //console.log(\"Tiles\");\n                  Lerc2Helpers.readTiles(input, data, OutPixelTypeArray, useBSQForOutputDim);\n                }\n              } else {\n                //lerc2.x non-8 bit data\n                //console.log(\"Tiles\");\n                Lerc2Helpers.readTiles(input, data, OutPixelTypeArray, useBSQForOutputDim);\n              }\n            }\n          }\n        }\n\n        data.eofOffset = data.ptr;\n        var diff;\n\n        if (options.inputOffset) {\n          diff = data.headerInfo.blobSize + options.inputOffset - data.ptr;\n\n          if (Math.abs(diff) >= 1) {\n            //console.debug(\"incorrect eof: dataptr \" + data.ptr + \" offset \" + options.inputOffset + \" blobsize \" + data.headerInfo.blobSize + \" diff: \" + diff);\n            data.eofOffset = options.inputOffset + data.headerInfo.blobSize;\n          }\n        } else {\n          diff = data.headerInfo.blobSize - data.ptr;\n\n          if (Math.abs(diff) >= 1) {\n            //console.debug(\"incorrect first band eof: dataptr \" + data.ptr + \" blobsize \" + data.headerInfo.blobSize + \" diff: \" + diff);\n            data.eofOffset = data.headerInfo.blobSize;\n          }\n        }\n\n        var result = {\n          width: headerInfo.width,\n          height: headerInfo.height,\n          pixelData: data.pixels.resultPixels,\n          minValue: headerInfo.zMin,\n          maxValue: headerInfo.zMax,\n          validPixelCount: headerInfo.numValidPixel,\n          dimCount: headerInfo.numDims,\n          dimStats: {\n            minValues: headerInfo.minValues,\n            maxValues: headerInfo.maxValues\n          },\n          maskData: data.pixels.resultMask //noDataValue: noDataValue\n\n        }; //we should remove this if there's no existing client\n        //optional noDataValue processing, it's user's responsiblity\n\n        if (data.pixels.resultMask && Lerc2Helpers.isValidPixelValue(headerInfo.imageType, noDataValue)) {\n          var mask = data.pixels.resultMask;\n\n          for (i = 0; i < numPixels; i++) {\n            if (!mask[i]) {\n              result.pixelData[i] = noDataValue;\n            }\n          }\n\n          result.noDataValue = noDataValue;\n        }\n\n        data.noDataValue = noDataValue;\n\n        if (options.returnFileInfo) {\n          result.fileInfo = Lerc2Helpers.formatFileInfo(data);\n        }\n\n        return result;\n      },\n      getBandCount: function (\n      /*byte array*/\n      input) {\n        var count = 0;\n        var i = 0;\n        var temp = {};\n        temp.ptr = 0;\n        temp.pixels = {};\n\n        while (i < input.byteLength - 58) {\n          Lerc2Helpers.readHeaderInfo(input, temp);\n          i += temp.headerInfo.blobSize;\n          count++;\n          temp.ptr = i;\n        }\n\n        return count;\n      }\n    };\n    return Lerc2Decode;\n  }();\n\n  var isPlatformLittleEndian = function () {\n    var a = new ArrayBuffer(4);\n    var b = new Uint8Array(a);\n    var c = new Uint32Array(a);\n    c[0] = 1;\n    return b[0] === 1;\n  }();\n\n  var Lerc = {\n    /************wrapper**********************************************/\n\n    /**\n     * A wrapper for decoding both LERC1 and LERC2 byte streams capable of handling multiband pixel blocks for various pixel types.\n     *\n     * @alias module:Lerc\n     * @param {ArrayBuffer} input The LERC input byte stream\n     * @param {object} [options] The decoding options below are optional.\n     * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid Lerc file is expected at that position.\n     * @param {string} [options.pixelType] (LERC1 only) Default value is F32. Valid pixel types for input are U8/S8/S16/U16/S32/U32/F32.\n     * @param {number} [options.noDataValue] (LERC1 only). It is recommended to use the returned mask instead of setting this value.\n     * @param {boolean} [options.returnPixelInterleavedDims] (nDim LERC2 only) If true, returned dimensions are pixel-interleaved, a.k.a [p1_dim0, p1_dim1, p1_dimn, p2_dim0...], default is [p1_dim0, p2_dim0, ..., p1_dim1, p2_dim1...]\n     * @returns {{width, height, pixels, pixelType, mask, statistics}}\n       * @property {number} width Width of decoded image.\n       * @property {number} height Height of decoded image.\n       * @property {array} pixels [band1, band2, ] Each band is a typed array of width*height.\n       * @property {string} pixelType The type of pixels represented in the output.\n       * @property {mask} mask Typed array with a size of width*height, or null if all pixels are valid.\n       * @property {array} statistics [statistics_band1, statistics_band2, ] Each element is a statistics object representing min and max values\n    **/\n    decode: function (encodedData, options) {\n      if (!isPlatformLittleEndian) {\n        throw \"Big endian system is not supported.\";\n      }\n\n      options = options || {};\n      var inputOffset = options.inputOffset || 0;\n      var fileIdView = new Uint8Array(encodedData, inputOffset, 10);\n      var fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\n      var lerc, majorVersion;\n\n      if (fileIdentifierString.trim() === \"CntZImage\") {\n        lerc = LercDecode;\n        majorVersion = 1;\n      } else if (fileIdentifierString.substring(0, 5) === \"Lerc2\") {\n        lerc = Lerc2Decode;\n        majorVersion = 2;\n      } else {\n        throw \"Unexpected file identifier string: \" + fileIdentifierString;\n      }\n\n      var iPlane = 0,\n          eof = encodedData.byteLength - 10,\n          encodedMaskData,\n          bandMasks = [],\n          bandMask,\n          maskData;\n      var decodedPixelBlock = {\n        width: 0,\n        height: 0,\n        pixels: [],\n        pixelType: options.pixelType,\n        mask: null,\n        statistics: []\n      };\n      var uniqueBandMaskCount = 0;\n\n      while (inputOffset < eof) {\n        var result = lerc.decode(encodedData, {\n          inputOffset: inputOffset,\n          //for both lerc1 and lerc2\n          encodedMaskData: encodedMaskData,\n          //lerc1 only\n          maskData: maskData,\n          //lerc2 only\n          returnMask: iPlane === 0 ? true : false,\n          //lerc1 only\n          returnEncodedMask: iPlane === 0 ? true : false,\n          //lerc1 only\n          returnFileInfo: true,\n          //for both lerc1 and lerc2\n          returnPixelInterleavedDims: options.returnPixelInterleavedDims,\n          //for ndim lerc2 only\n          pixelType: options.pixelType || null,\n          //lerc1 only\n          noDataValue: options.noDataValue || null //lerc1 only\n\n        });\n        inputOffset = result.fileInfo.eofOffset;\n        maskData = result.maskData; //lerc2\n\n        if (iPlane === 0) {\n          encodedMaskData = result.encodedMaskData; //lerc1\n\n          decodedPixelBlock.width = result.width;\n          decodedPixelBlock.height = result.height;\n          decodedPixelBlock.dimCount = result.dimCount || 1; //decodedPixelBlock.dimStats = decodedPixelBlock.dimStats;\n\n          decodedPixelBlock.pixelType = result.pixelType || result.fileInfo.pixelType;\n          decodedPixelBlock.mask = maskData;\n        }\n\n        if (majorVersion > 1) {\n          if (maskData) {\n            bandMasks.push(maskData);\n          }\n\n          if (result.fileInfo.mask && result.fileInfo.mask.numBytes > 0) {\n            uniqueBandMaskCount++;\n          }\n        }\n\n        iPlane++;\n        decodedPixelBlock.pixels.push(result.pixelData);\n        decodedPixelBlock.statistics.push({\n          minValue: result.minValue,\n          maxValue: result.maxValue,\n          noDataValue: result.noDataValue,\n          dimStats: result.dimStats\n        });\n      }\n\n      var i, j, numPixels;\n\n      if (majorVersion > 1 && uniqueBandMaskCount > 1) {\n        numPixels = decodedPixelBlock.width * decodedPixelBlock.height;\n        decodedPixelBlock.bandMasks = bandMasks;\n        maskData = new Uint8Array(numPixels);\n        maskData.set(bandMasks[0]);\n\n        for (i = 1; i < bandMasks.length; i++) {\n          bandMask = bandMasks[i];\n\n          for (j = 0; j < numPixels; j++) {\n            maskData[j] = maskData[j] & bandMask[j];\n          }\n        }\n\n        decodedPixelBlock.maskData = maskData;\n      }\n\n      return decodedPixelBlock;\n    }\n  };\n\n  if (typeof define === \"function\" && define.amd) {\n    /* jshint ignore:line */\n    //amd loaders such as dojo and requireJS\n    //http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\n    define([], function () {\n      return Lerc;\n    });\n    /* jshint ignore:line */\n  } else if (typeof module !== \"undefined\" && module.exports) {\n    /* jshint ignore:line */\n    //commonJS module 1.0/1.1/1.1.1 systems, such as nodeJS\n    //http://wiki.commonjs.org/wiki/Modules\n    module.exports = Lerc;\n    /* jshint ignore:line */\n  } else {\n    //assign to this, most likely window\n    this.Lerc = Lerc;\n  }\n})();","map":null,"metadata":{},"sourceType":"script"}