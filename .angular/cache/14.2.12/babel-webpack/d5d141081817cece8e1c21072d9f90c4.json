{"ast":null,"code":"function decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n\n    count -= stride;\n  }\n\n  const copy = row.slice();\n\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[bytesPerSample * i + b] = copy[(bytesPerSample - b - 1) * wc + i];\n    }\n  }\n}\n\nexport function applyPredictor(block, predictor, width, height, bitsPerSample, planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n\n    let row;\n\n    if (predictor === 2) {\n      // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample);\n          break;\n\n        case 16:\n          row = new Uint16Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2);\n          break;\n\n        case 32:\n          row = new Uint32Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4);\n          break;\n\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) {\n      // horizontal floating point\n      row = new Uint8Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample);\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n\n  return block;\n}","map":null,"metadata":{},"sourceType":"module"}