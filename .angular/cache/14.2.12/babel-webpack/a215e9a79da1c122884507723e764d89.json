{"ast":null,"code":"/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\nimport { fieldTagNames, fieldTagTypes, fieldTypeNames, geoKeyNames } from './globals.js';\nimport { assign, endsWith, forEach, invert, times } from './utils.js';\nconst tagName2Code = invert(fieldTagNames);\nconst geoKeyName2Code = invert(geoKeyNames);\nconst name2code = {};\nassign(name2code, tagName2Code);\nassign(name2code, geoKeyName2Code);\nconst typeName2byte = invert(fieldTypeNames); // config variables\n\nconst numBytesInIfd = 1000;\nconst _binBE = {\n  nextZero: (data, o) => {\n    let oincr = o;\n\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n\n    return oincr;\n  },\n  readUshort: (buff, p) => {\n    return buff[p] << 8 | buff[p + 1];\n  },\n  readShort: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: (buff, p, l) => {\n    return l.map(i => String.fromCharCode(buff[p + i])).join('');\n  },\n  readFloat: (buff, p) => {\n    const a = _binBE.ui8;\n    times(4, i => {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: (buff, p) => {\n    const a = _binBE.ui8;\n    times(8, i => {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: (buff, p, n) => {\n    buff[p] = n >> 8 & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: (buff, p, n) => {\n    buff[p] = n >> 24 & 255;\n    buff[p + 1] = n >> 16 & 255;\n    buff[p + 2] = n >> 8 & 255;\n    buff[p + 3] = n >> 0 & 255;\n  },\n  writeASCII: (buff, p, s) => {\n    times(s.length, i => {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8)\n};\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n\n_binBE.writeDouble = (buff, p, n) => {\n  _binBE.fl64[0] = n;\n  times(8, i => {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\n\nconst _writeIFD = (bin, data, _offset, ifd) => {\n  let offset = _offset;\n  const keys = Object.keys(ifd).filter(key => {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n  let eoff = offset + 12 * keys.length + 4;\n\n  for (const key of keys) {\n    let tag = null;\n\n    if (typeof key === 'number') {\n      tag = key;\n    } else if (typeof key === 'string') {\n      tag = parseInt(key, 10);\n    }\n\n    const typeName = fieldTagTypes[tag];\n    const typeNum = typeName2byte[typeName];\n\n    if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n      throw new Error(`unknown type of tag: ${tag}`);\n    }\n\n    let val = ifd[key];\n\n    if (val === undefined) {\n      throw new Error(`failed to get value for key ${key}`);\n    } // ASCIIZ format with trailing 0 character\n    // http://www.fileformat.info/format/tiff/corion.htm\n    // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n\n\n    if (typeName === 'ASCII' && typeof val === 'string' && endsWith(val, '\\u0000') === false) {\n      val += '\\u0000';\n    }\n\n    const num = val.length;\n    bin.writeUshort(data, offset, tag);\n    offset += 2;\n    bin.writeUshort(data, offset, typeNum);\n    offset += 2;\n    bin.writeUint(data, offset, num);\n    offset += 4;\n    let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n    let toff = offset;\n\n    if (dlen > 4) {\n      bin.writeUint(data, offset, eoff);\n      toff = eoff;\n    }\n\n    if (typeName === 'ASCII') {\n      bin.writeASCII(data, toff, val);\n    } else if (typeName === 'SHORT') {\n      times(num, i => {\n        bin.writeUshort(data, toff + 2 * i, val[i]);\n      });\n    } else if (typeName === 'LONG') {\n      times(num, i => {\n        bin.writeUint(data, toff + 4 * i, val[i]);\n      });\n    } else if (typeName === 'RATIONAL') {\n      times(num, i => {\n        bin.writeUint(data, toff + 8 * i, Math.round(val[i] * 10000));\n        bin.writeUint(data, toff + 8 * i + 4, 10000);\n      });\n    } else if (typeName === 'DOUBLE') {\n      times(num, i => {\n        bin.writeDouble(data, toff + 8 * i, val[i]);\n      });\n    }\n\n    if (dlen > 4) {\n      dlen += dlen & 1;\n      eoff += dlen;\n    }\n\n    offset += 4;\n  }\n\n  return [offset, eoff];\n};\n\nconst encodeIfds = ifds => {\n  const data = new Uint8Array(numBytesInIfd);\n  let offset = 4;\n  const bin = _binBE; // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n\n  data[0] = 77;\n  data[1] = 77; // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n\n  data[3] = 42;\n  let ifdo = 8;\n  bin.writeUint(data, offset, ifdo);\n  offset += 4;\n  ifds.forEach((ifd, i) => {\n    const noffs = _writeIFD(bin, data, ifdo, ifd);\n\n    ifdo = noffs[1];\n\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  } // node hasn't implemented slice on Uint8Array yet\n\n\n  const result = new Uint8Array(ifdo);\n\n  for (let i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n\n  return result.buffer;\n};\n\nconst encodeImage = (values, width, height, metadata) => {\n  if (height === undefined || height === null) {\n    throw new Error(`you passed into encodeImage a width of type ${height}`);\n  }\n\n  if (width === undefined || width === null) {\n    throw new Error(`you passed into encodeImage a width of type ${width}`);\n  }\n\n  const ifd = {\n    256: [width],\n    // ImageWidth\n    257: [height],\n    // ImageLength\n    273: [numBytesInIfd],\n    // strips offset\n    278: [height],\n    // RowsPerStrip\n    305: 'geotiff.js' // no array for ASCII(Z)\n\n  };\n\n  if (metadata) {\n    for (const i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n\n  const prfx = new Uint8Array(encodeIfds([ifd]));\n  const img = new Uint8Array(values);\n  const samplesPerPixel = ifd[277];\n  const data = new Uint8Array(numBytesInIfd + width * height * samplesPerPixel);\n  times(prfx.length, i => {\n    data[i] = prfx[i];\n  });\n  forEach(img, (value, i) => {\n    data[numBytesInIfd + i] = value;\n  });\n  return data.buffer;\n};\n\nconst convertToTids = input => {\n  const result = {};\n\n  for (const key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n\n      result[name2code[key]] = input[key];\n    }\n  }\n\n  return result;\n};\n\nconst toArray = input => {\n  if (Array.isArray(input)) {\n    return input;\n  }\n\n  return [input];\n};\n\nconst metadataDefaults = [['Compression', 1], // no compression\n['PlanarConfiguration', 1], ['ExtraSamples', 0]];\nexport function writeGeotiff(data, metadata) {\n  const isFlattened = typeof data[0] === 'number';\n  let height;\n  let numBands;\n  let width;\n  let flattenedValues;\n\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    times(height, rowIndex => {\n      times(width, columnIndex => {\n        times(numBands, bandIndex => {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width; // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = times(numBands, () => 8);\n  }\n\n  metadataDefaults.forEach(tag => {\n    const key = tag[0];\n\n    if (!metadata[key]) {\n      const value = tag[1];\n      metadata[key] = value;\n    }\n  }); // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  } // The number of components per pixel.\n\n\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = times(numBands, () => 1);\n  } // if didn't pass in projection information, assume the popular 4326 \"geographic projection\"\n\n\n  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {\n    metadata.GeographicTypeGeoKey = 4326;\n    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe\n\n    metadata.GeogCitationGeoKey = 'WGS 84';\n    metadata.GTModelTypeGeoKey = 2;\n  }\n\n  const geoKeys = Object.keys(metadata).filter(key => endsWith(key, 'GeoKey')).sort((a, b) => name2code[a] - name2code[b]);\n\n  if (!metadata.GeoAsciiParams) {\n    let geoAsciiParams = '';\n    geoKeys.forEach(name => {\n      const code = Number(name2code[name]);\n      const tagType = fieldTagTypes[code];\n\n      if (tagType === 'ASCII') {\n        geoAsciiParams += `${metadata[name].toString()}\\u0000`;\n      }\n    });\n\n    if (geoAsciiParams.length > 0) {\n      metadata.GeoAsciiParams = geoAsciiParams;\n    }\n  }\n\n  if (!metadata.GeoKeyDirectory) {\n    const NumberOfKeys = geoKeys.length;\n    const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach(geoKey => {\n      const KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n      let Count;\n      let TIFFTagLocation;\n      let valueOffset;\n\n      if (fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);\n      }\n\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  } // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n\n\n  for (const geoKey in geoKeys) {\n    if (geoKeys.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n\n  ['Compression', 'ExtraSamples', 'GeographicTypeGeoKey', 'GTModelTypeGeoKey', 'GTRasterTypeGeoKey', 'ImageLength', // synonym of ImageHeight\n  'ImageWidth', 'Orientation', 'PhotometricInterpretation', 'ProjectedCSTypeGeoKey', 'PlanarConfiguration', 'ResolutionUnit', 'SamplesPerPixel', 'XPosition', 'YPosition'].forEach(name => {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n  const encodedMetadata = convertToTids(metadata);\n  const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n  return outputImage;\n}","map":null,"metadata":{},"sourceType":"module"}