{"ast":null,"code":"export default class DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(offset - this._sliceOffset, this._littleEndian);\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(offset - this._sliceOffset, this._littleEndian);\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(offset - this._sliceOffset, this._littleEndian);\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(offset - this._sliceOffset, this._littleEndian);\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(offset - this._sliceOffset, this._littleEndian);\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(offset - this._sliceOffset, this._littleEndian);\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(offset - this._sliceOffset, this._littleEndian);\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(offset - this._sliceOffset, this._littleEndian);\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n\n    if (this._littleEndian) {\n      combined = left + 2 ** 32 * right;\n\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. ` + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues');\n      }\n\n      return combined;\n    }\n\n    combined = 2 ** 32 * left + right;\n\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. ` + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues');\n    }\n\n    return combined;\n  } // adapted from https://stackoverflow.com/a/55338384/8060591\n\n\n  readInt64(offset) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (this._littleEndian ? i : 7 - i));\n\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n\n      value += byte * 256 ** i;\n    }\n\n    if (isNegative) {\n      value = -value;\n    }\n\n    return value;\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n\n    return this.readUint32(offset);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}