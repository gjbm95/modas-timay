{"ast":null,"code":"export default class QuickLRU extends Map {\n  constructor(options = {}) {\n    super();\n\n    if (!(options.maxSize && options.maxSize > 0)) {\n      throw new TypeError('`maxSize` must be a number greater than 0');\n    }\n\n    if (typeof options.maxAge === 'number' && options.maxAge === 0) {\n      throw new TypeError('`maxAge` must be a number greater than 0');\n    } // TODO: Use private class fields when ESLint supports them.\n\n\n    this.maxSize = options.maxSize;\n    this.maxAge = options.maxAge || Number.POSITIVE_INFINITY;\n    this.onEviction = options.onEviction;\n    this.cache = new Map();\n    this.oldCache = new Map();\n    this._size = 0;\n  } // TODO: Use private class methods when targeting Node.js 16.\n\n\n  _emitEvictions(cache) {\n    if (typeof this.onEviction !== 'function') {\n      return;\n    }\n\n    for (const [key, item] of cache) {\n      this.onEviction(key, item.value);\n    }\n  }\n\n  _deleteIfExpired(key, item) {\n    if (typeof item.expiry === 'number' && item.expiry <= Date.now()) {\n      if (typeof this.onEviction === 'function') {\n        this.onEviction(key, item.value);\n      }\n\n      return this.delete(key);\n    }\n\n    return false;\n  }\n\n  _getOrDeleteIfExpired(key, item) {\n    const deleted = this._deleteIfExpired(key, item);\n\n    if (deleted === false) {\n      return item.value;\n    }\n  }\n\n  _getItemValue(key, item) {\n    return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;\n  }\n\n  _peek(key, cache) {\n    const item = cache.get(key);\n    return this._getItemValue(key, item);\n  }\n\n  _set(key, value) {\n    this.cache.set(key, value);\n    this._size++;\n\n    if (this._size >= this.maxSize) {\n      this._size = 0;\n\n      this._emitEvictions(this.oldCache);\n\n      this.oldCache = this.cache;\n      this.cache = new Map();\n    }\n  }\n\n  _moveToRecent(key, item) {\n    this.oldCache.delete(key);\n\n    this._set(key, item);\n  }\n\n  *_entriesAscending() {\n    for (const item of this.oldCache) {\n      const [key, value] = item;\n\n      if (!this.cache.has(key)) {\n        const deleted = this._deleteIfExpired(key, value);\n\n        if (deleted === false) {\n          yield item;\n        }\n      }\n    }\n\n    for (const item of this.cache) {\n      const [key, value] = item;\n\n      const deleted = this._deleteIfExpired(key, value);\n\n      if (deleted === false) {\n        yield item;\n      }\n    }\n  }\n\n  get(key) {\n    if (this.cache.has(key)) {\n      const item = this.cache.get(key);\n      return this._getItemValue(key, item);\n    }\n\n    if (this.oldCache.has(key)) {\n      const item = this.oldCache.get(key);\n\n      if (this._deleteIfExpired(key, item) === false) {\n        this._moveToRecent(key, item);\n\n        return item.value;\n      }\n    }\n  }\n\n  set(key, value, {\n    maxAge = this.maxAge\n  } = {}) {\n    const expiry = typeof maxAge === 'number' && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : undefined;\n\n    if (this.cache.has(key)) {\n      this.cache.set(key, {\n        value,\n        expiry\n      });\n    } else {\n      this._set(key, {\n        value,\n        expiry\n      });\n    }\n  }\n\n  has(key) {\n    if (this.cache.has(key)) {\n      return !this._deleteIfExpired(key, this.cache.get(key));\n    }\n\n    if (this.oldCache.has(key)) {\n      return !this._deleteIfExpired(key, this.oldCache.get(key));\n    }\n\n    return false;\n  }\n\n  peek(key) {\n    if (this.cache.has(key)) {\n      return this._peek(key, this.cache);\n    }\n\n    if (this.oldCache.has(key)) {\n      return this._peek(key, this.oldCache);\n    }\n  }\n\n  delete(key) {\n    const deleted = this.cache.delete(key);\n\n    if (deleted) {\n      this._size--;\n    }\n\n    return this.oldCache.delete(key) || deleted;\n  }\n\n  clear() {\n    this.cache.clear();\n    this.oldCache.clear();\n    this._size = 0;\n  }\n\n  resize(newSize) {\n    if (!(newSize && newSize > 0)) {\n      throw new TypeError('`maxSize` must be a number greater than 0');\n    }\n\n    const items = [...this._entriesAscending()];\n    const removeCount = items.length - newSize;\n\n    if (removeCount < 0) {\n      this.cache = new Map(items);\n      this.oldCache = new Map();\n      this._size = items.length;\n    } else {\n      if (removeCount > 0) {\n        this._emitEvictions(items.slice(0, removeCount));\n      }\n\n      this.oldCache = new Map(items.slice(removeCount));\n      this.cache = new Map();\n      this._size = 0;\n    }\n\n    this.maxSize = newSize;\n  }\n\n  *keys() {\n    for (const [key] of this) {\n      yield key;\n    }\n  }\n\n  *values() {\n    for (const [, value] of this) {\n      yield value;\n    }\n  }\n\n  *[Symbol.iterator]() {\n    for (const item of this.cache) {\n      const [key, value] = item;\n\n      const deleted = this._deleteIfExpired(key, value);\n\n      if (deleted === false) {\n        yield [key, value.value];\n      }\n    }\n\n    for (const item of this.oldCache) {\n      const [key, value] = item;\n\n      if (!this.cache.has(key)) {\n        const deleted = this._deleteIfExpired(key, value);\n\n        if (deleted === false) {\n          yield [key, value.value];\n        }\n      }\n    }\n  }\n\n  *entriesDescending() {\n    let items = [...this.cache];\n\n    for (let i = items.length - 1; i >= 0; --i) {\n      const item = items[i];\n      const [key, value] = item;\n\n      const deleted = this._deleteIfExpired(key, value);\n\n      if (deleted === false) {\n        yield [key, value.value];\n      }\n    }\n\n    items = [...this.oldCache];\n\n    for (let i = items.length - 1; i >= 0; --i) {\n      const item = items[i];\n      const [key, value] = item;\n\n      if (!this.cache.has(key)) {\n        const deleted = this._deleteIfExpired(key, value);\n\n        if (deleted === false) {\n          yield [key, value.value];\n        }\n      }\n    }\n  }\n\n  *entriesAscending() {\n    for (const [key, value] of this._entriesAscending()) {\n      yield [key, value.value];\n    }\n  }\n\n  get size() {\n    if (!this._size) {\n      return this.oldCache.size;\n    }\n\n    let oldCacheSize = 0;\n\n    for (const key of this.oldCache.keys()) {\n      if (!this.cache.has(key)) {\n        oldCacheSize++;\n      }\n    }\n\n    return Math.min(this._size + oldCacheSize, this.maxSize);\n  }\n\n  entries() {\n    return this.entriesAscending();\n  }\n\n  forEach(callbackFunction, thisArgument = this) {\n    for (const [key, value] of this.entriesAscending()) {\n      callbackFunction.call(thisArgument, value, key, this);\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return JSON.stringify([...this.entriesAscending()]);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}