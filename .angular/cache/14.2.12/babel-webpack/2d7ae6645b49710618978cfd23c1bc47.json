{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Usuario/Documents/Trabajos para empresas/Modas Timay Fashion/Pagina web/modas-timay/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { getDecoder } from './compression/index.js';\nconst defaultPoolSize = typeof navigator !== 'undefined' ? navigator.hardwareConcurrency || 2 : 2;\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\n\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  constructor(size = defaultPoolSize, createWorker) {\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise(resolve => {\n        import('./worker/decoder.js').then(module => {\n          resolve(module.create);\n        });\n      });\n\n      this._awaitingDecoder.then(create => {\n        this._awaitingDecoder = null;\n        this.workers = [];\n\n        for (let i = 0; i < size; i++) {\n          this.workers.push({\n            worker: create(),\n            idle: true\n          });\n        }\n      });\n    }\n  }\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n\n\n  decode(fileDirectory, buffer) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this._awaitingDecoder) {\n        yield _this._awaitingDecoder;\n      }\n\n      return _this.size === 0 ? getDecoder(fileDirectory).then(decoder => decoder.decode(fileDirectory, buffer)) : new Promise(resolve => {\n        const worker = _this.workers.find(candidate => candidate.idle) || _this.workers[Math.floor(Math.random() * _this.size)];\n\n        worker.idle = false;\n        const id = _this.messageId++;\n\n        const onMessage = e => {\n          if (e.data.id === id) {\n            worker.idle = true;\n            resolve(e.data.decoded);\n            worker.worker.removeEventListener('message', onMessage);\n          }\n        };\n\n        worker.worker.addEventListener('message', onMessage);\n        worker.worker.postMessage({\n          fileDirectory,\n          buffer,\n          id\n        }, [buffer]);\n      });\n    })();\n  }\n\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach(worker => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n\n}\n\nexport default Pool;","map":null,"metadata":{},"sourceType":"module"}