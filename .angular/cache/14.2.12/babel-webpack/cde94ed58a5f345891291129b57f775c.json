{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Usuario/Documents/Trabajos para empresas/Modas Timay Fashion/Pagina web/modas-timay/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n\n/** @typedef {import(\"./geotiff.js\").ReadRasterResult} ReadRasterResult */\n\nfunction sum(array, start, end) {\n  let s = 0;\n\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1:\n      // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n\n      break;\n\n    case 2:\n      // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n\n      break;\n\n    case 3:\n      // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n\n        case 64:\n          return new Float64Array(size);\n\n        default:\n          break;\n      }\n\n      break;\n\n    default:\n      break;\n  }\n\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2 ? tileHeight * tileWidth : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2 ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize); // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) {\n    // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip; // let sampleBitOffset = 0;\n\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample; // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    } // Bits per line rounds up to next byte boundary.\n\n\n    let bitsPerLine = tileWidth * pixelBitSkip;\n\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = bitsPerLine + 7 & ~7;\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + x * samplesToTransfer * bitsPerSample;\n\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + i * bitsPerSample;\n          const outIndex = (y * tileWidth + x) * samplesToTransfer + i;\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = view.getUint8(byteOffset) >> 8 - bitsPerSample - innerBitOffset & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = view.getUint16(byteOffset) >> 16 - bitsPerSample - innerBitOffset & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = view.getUint16(byteOffset) << 8 | view.getUint8(byteOffset + 2);\n            outArray[outIndex] = raw >> 24 - bitsPerSample - innerBitOffset & bitMask;\n          } else {\n            outArray[outIndex] = view.getUint32(byteOffset) >> 32 - bitsPerSample - innerBitOffset & bitMask;\n          } // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n\n        } // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n\n      }\n    }\n  } else if (format === 3) {// floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n/**\n * GeoTIFF sub-file image.\n */\n\n\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {import('./source/basesource').BaseSource} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = typeof planarConfiguration === 'undefined' ? 1 : planarConfiguration;\n\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n\n\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n\n\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n\n\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n\n\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n\n\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined' ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n\n\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n\n\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - y * this.getTileHeight();\n    }\n  }\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n\n\n  getBytesPerPixel() {\n    let bytes = 0;\n\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n\n    switch (format) {\n      case 1:\n        // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n\n        break;\n\n      case 2:\n        // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n\n        break;\n\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n\n          case 32:\n            return DataView.prototype.getFloat32;\n\n          case 64:\n            return DataView.prototype.getFloat64;\n\n          default:\n            break;\n        }\n\n        break;\n\n      default:\n        break;\n    }\n\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|import(\"./geotiff\").BaseDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n\n\n  getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const numTilesPerRow = Math.ceil(_this.getWidth() / _this.getTileWidth());\n      const numTilesPerCol = Math.ceil(_this.getHeight() / _this.getTileHeight());\n      let index;\n      const {\n        tiles\n      } = _this;\n\n      if (_this.planarConfiguration === 1) {\n        index = y * numTilesPerRow + x;\n      } else if (_this.planarConfiguration === 2) {\n        index = sample * numTilesPerRow * numTilesPerCol + y * numTilesPerRow + x;\n      }\n\n      let offset;\n      let byteCount;\n\n      if (_this.isTiled) {\n        offset = _this.fileDirectory.TileOffsets[index];\n        byteCount = _this.fileDirectory.TileByteCounts[index];\n      } else {\n        offset = _this.fileDirectory.StripOffsets[index];\n        byteCount = _this.fileDirectory.StripByteCounts[index];\n      }\n\n      const slice = (yield _this.source.fetch([{\n        offset,\n        length: byteCount\n      }], signal))[0];\n      let request;\n\n      if (tiles === null || !tiles[index]) {\n        // resolve each request by potentially applying array normalization\n        request = _asyncToGenerator(function* () {\n          let data = yield poolOrDecoder.decode(_this.fileDirectory, slice);\n\n          const sampleFormat = _this.getSampleFormat();\n\n          const bitsPerSample = _this.getBitsPerSample();\n\n          if (needsNormalization(sampleFormat, bitsPerSample)) {\n            data = normalizeArray(data, sampleFormat, _this.planarConfiguration, _this.getSamplesPerPixel(), bitsPerSample, _this.getTileWidth(), _this.getBlockHeight(y));\n          }\n\n          return data;\n        })(); // set the cache\n\n        if (tiles !== null) {\n          tiles[index] = request;\n        }\n      } else {\n        // get from the cache\n        request = tiles[index];\n      } // cache the tile request\n\n\n      return {\n        x,\n        y,\n        sample,\n        data: yield request\n      };\n    })();\n  }\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<ReadRasterResult>}\n   */\n\n\n  _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const tileWidth = _this2.getTileWidth();\n\n      const tileHeight = _this2.getTileHeight();\n\n      const imageWidth = _this2.getWidth();\n\n      const imageHeight = _this2.getHeight();\n\n      const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n      const maxXTile = Math.min(Math.ceil(imageWindow[2] / tileWidth), Math.ceil(imageWidth / tileWidth));\n      const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n      const maxYTile = Math.min(Math.ceil(imageWindow[3] / tileHeight), Math.ceil(imageHeight / tileHeight));\n      const windowWidth = imageWindow[2] - imageWindow[0];\n\n      let bytesPerPixel = _this2.getBytesPerPixel();\n\n      const srcSampleOffsets = [];\n      const sampleReaders = [];\n\n      for (let i = 0; i < samples.length; ++i) {\n        if (_this2.planarConfiguration === 1) {\n          srcSampleOffsets.push(sum(_this2.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n        } else {\n          srcSampleOffsets.push(0);\n        }\n\n        sampleReaders.push(_this2.getReaderForSample(samples[i]));\n      }\n\n      const promises = [];\n      const {\n        littleEndian\n      } = _this2;\n\n      for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n        for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n          for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n            const si = sampleIndex;\n            const sample = samples[sampleIndex];\n\n            if (_this2.planarConfiguration === 2) {\n              bytesPerPixel = _this2.getSampleByteSize(sampleIndex);\n            }\n\n            const promise = _this2.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal).then(tile => {\n              const buffer = tile.data;\n              const dataView = new DataView(buffer);\n\n              const blockHeight = _this2.getBlockHeight(tile.y);\n\n              const firstLine = tile.y * tileHeight;\n              const firstCol = tile.x * tileWidth;\n              const lastLine = firstLine + blockHeight;\n              const lastCol = (tile.x + 1) * tileWidth;\n              const reader = sampleReaders[si];\n              const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n              const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n              for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n                for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                  const pixelOffset = (y * tileWidth + x) * bytesPerPixel;\n                  const value = reader.call(dataView, pixelOffset + srcSampleOffsets[si], littleEndian);\n                  let windowCoordinate;\n\n                  if (interleave) {\n                    windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth * samples.length + (x + firstCol - imageWindow[0]) * samples.length + si;\n                    valueArrays[windowCoordinate] = value;\n                  } else {\n                    windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth + x + firstCol - imageWindow[0];\n                    valueArrays[si][windowCoordinate] = value;\n                  }\n                }\n              }\n            });\n\n            promises.push(promise);\n          }\n        }\n      }\n\n      yield Promise.all(promises);\n\n      if (width && imageWindow[2] - imageWindow[0] !== width || height && imageWindow[3] - imageWindow[1] !== height) {\n        let resampled;\n\n        if (interleave) {\n          resampled = resampleInterleaved(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, samples.length, resampleMethod);\n        } else {\n          resampled = resample(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, resampleMethod);\n        }\n\n        resampled.width = width;\n        resampled.height = height;\n        return resampled;\n      }\n\n      valueArrays.width = width || imageWindow[2] - imageWindow[0];\n      valueArrays.height = height || imageWindow[3] - imageWindow[1];\n      return valueArrays;\n    })();\n  }\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise\n   */\n\n\n  readRasters({\n    window: wnd,\n    samples = [],\n    interleave,\n    pool = null,\n    width,\n    height,\n    resampleMethod,\n    fillValue,\n    signal\n  } = {}) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const imageWindow = wnd || [0, 0, _this3.getWidth(), _this3.getHeight()]; // check parameters\n\n      if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n        throw new Error('Invalid subsets');\n      }\n\n      const imageWindowWidth = imageWindow[2] - imageWindow[0];\n      const imageWindowHeight = imageWindow[3] - imageWindow[1];\n      const numPixels = imageWindowWidth * imageWindowHeight;\n\n      const samplesPerPixel = _this3.getSamplesPerPixel();\n\n      if (!samples || !samples.length) {\n        for (let i = 0; i < samplesPerPixel; ++i) {\n          samples.push(i);\n        }\n      } else {\n        for (let i = 0; i < samples.length; ++i) {\n          if (samples[i] >= samplesPerPixel) {\n            return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n          }\n        }\n      }\n\n      let valueArrays;\n\n      if (interleave) {\n        const format = _this3.fileDirectory.SampleFormat ? Math.max.apply(null, _this3.fileDirectory.SampleFormat) : 1;\n        const bitsPerSample = Math.max.apply(null, _this3.fileDirectory.BitsPerSample);\n        valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n\n        if (fillValue) {\n          valueArrays.fill(fillValue);\n        }\n      } else {\n        valueArrays = [];\n\n        for (let i = 0; i < samples.length; ++i) {\n          const valueArray = _this3.getArrayForSample(samples[i], numPixels);\n\n          if (Array.isArray(fillValue) && i < fillValue.length) {\n            valueArray.fill(fillValue[i]);\n          } else if (fillValue && !Array.isArray(fillValue)) {\n            valueArray.fill(fillValue);\n          }\n\n          valueArrays.push(valueArray);\n        }\n      }\n\n      const poolOrDecoder = pool || (yield getDecoder(_this3.fileDirectory));\n      const result = yield _this3._readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal);\n      return result;\n    })();\n  }\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * grayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<ReadRasterResult>} the RGB array as a Promise\n   */\n\n\n  readRGB({\n    window,\n    interleave = true,\n    pool = null,\n    width,\n    height,\n    resampleMethod,\n    enableAlpha = false,\n    signal\n  } = {}) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const imageWindow = window || [0, 0, _this4.getWidth(), _this4.getHeight()]; // check parameters\n\n      if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n        throw new Error('Invalid subsets');\n      }\n\n      const pi = _this4.fileDirectory.PhotometricInterpretation;\n\n      if (pi === photometricInterpretations.RGB) {\n        let s = [0, 1, 2];\n\n        if (!(_this4.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified) && enableAlpha) {\n          s = [];\n\n          for (let i = 0; i < _this4.fileDirectory.BitsPerSample.length; i += 1) {\n            s.push(i);\n          }\n        }\n\n        return _this4.readRasters({\n          window,\n          interleave,\n          samples: s,\n          pool,\n          width,\n          height,\n          resampleMethod,\n          signal\n        });\n      }\n\n      let samples;\n\n      switch (pi) {\n        case photometricInterpretations.WhiteIsZero:\n        case photometricInterpretations.BlackIsZero:\n        case photometricInterpretations.Palette:\n          samples = [0];\n          break;\n\n        case photometricInterpretations.CMYK:\n          samples = [0, 1, 2, 3];\n          break;\n\n        case photometricInterpretations.YCbCr:\n        case photometricInterpretations.CIELab:\n          samples = [0, 1, 2];\n          break;\n\n        default:\n          throw new Error('Invalid or unsupported photometric interpretation.');\n      }\n\n      const subOptions = {\n        window: imageWindow,\n        interleave: true,\n        samples,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal\n      };\n      const {\n        fileDirectory\n      } = _this4;\n      const raster = yield _this4.readRasters(subOptions);\n      const max = 2 ** _this4.fileDirectory.BitsPerSample[0];\n      let data;\n\n      switch (pi) {\n        case photometricInterpretations.WhiteIsZero:\n          data = fromWhiteIsZero(raster, max);\n          break;\n\n        case photometricInterpretations.BlackIsZero:\n          data = fromBlackIsZero(raster, max);\n          break;\n\n        case photometricInterpretations.Palette:\n          data = fromPalette(raster, fileDirectory.ColorMap);\n          break;\n\n        case photometricInterpretations.CMYK:\n          data = fromCMYK(raster);\n          break;\n\n        case photometricInterpretations.YCbCr:\n          data = fromYCbCr(raster);\n          break;\n\n        case photometricInterpretations.CIELab:\n          data = fromCIELab(raster);\n          break;\n\n        default:\n          throw new Error('Unsupported photometric interpretation.');\n      } // if non-interleaved data is requested, we must split the channels\n      // into their respective arrays\n\n\n      if (!interleave) {\n        const red = new Uint8Array(data.length / 3);\n        const green = new Uint8Array(data.length / 3);\n        const blue = new Uint8Array(data.length / 3);\n\n        for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n          red[j] = data[i];\n          green[j] = data[i + 1];\n          blue[j] = data[i + 2];\n        }\n\n        data = [red, green, blue];\n      }\n\n      data.width = raster.width;\n      data.height = raster.height;\n      return data;\n    })();\n  }\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n\n\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5]\n      });\n    }\n\n    return tiePoints;\n  }\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n\n\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n\n    const string = this.fileDirectory.GDAL_METADATA;\n    let items = findTagsByName(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter(item => getAttribute(item, 'sample') === undefined);\n    } else {\n      items = items.filter(item => Number(getAttribute(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n\n    return metadata;\n  }\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n\n\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n\n\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (tiePoints && tiePoints.length === 6) {\n      return [tiePoints[3], tiePoints[4], tiePoints[5]];\n    }\n\n    if (modelTransformation) {\n      return [modelTransformation[3], modelTransformation[7], modelTransformation[11]];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n\n\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [modelPixelScale[0], -modelPixelScale[1], modelPixelScale[2]];\n    }\n\n    if (modelTransformation) {\n      return [modelTransformation[0], modelTransformation[5], modelTransformation[10]];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [refResX * referenceImage.getWidth() / this.getWidth(), refResY * referenceImage.getHeight() / this.getHeight(), refResZ * referenceImage.getWidth() / this.getWidth()];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n\n\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @returns {Array<number>} The bounding box\n   */\n\n\n  getBoundingBox() {\n    const origin = this.getOrigin();\n    const resolution = this.getResolution();\n    const x1 = origin[0];\n    const y1 = origin[1];\n    const x2 = x1 + resolution[0] * this.getWidth();\n    const y2 = y1 + resolution[1] * this.getHeight();\n    return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];\n  }\n\n}\n\nexport default GeoTIFFImage;","map":null,"metadata":{},"sourceType":"module"}