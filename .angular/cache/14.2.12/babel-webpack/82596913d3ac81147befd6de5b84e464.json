{"ast":null,"code":"/**\n * @module ol/source/DataTile\n */\nimport DataTile from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport ReprojDataTile from '../reproj/DataTile.js';\nimport TileCache from '../TileCache.js';\nimport TileEventType from './TileEventType.js';\nimport TileSource, { TileSourceEvent } from './Tile.js';\nimport TileState from '../TileState.js';\nimport { createXYZ, extentFromProjection, getForProjection as getTileGridForProjection } from '../tilegrid.js';\nimport { equivalent, get as getProjection } from '../proj.js';\nimport { getKeyZXY } from '../tilecoord.js';\nimport { getUid } from '../util.js';\nimport { toPromise } from '../functions.js';\nimport { toSize } from '../size.js';\n/**\n * Data tile loading function.  The function is called with z, x, and y tile coordinates and\n * returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * @typedef {function(number, number, number) : (import(\"../DataTile.js\").Data|Promise<import(\"../DataTile.js\").Data>)} Loader\n */\n\n/**\n * @typedef {Object} Options\n * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.\n * Returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * For loaders that generate images, the promise should not resolve until the image is loaded.\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The pixel width and height of the source tiles.\n * This may be different than the rendered pixel size if a `tileGrid` is provided.\n * @property {number} [gutter=0] The size in pixels of the gutter around data tiles to ignore.\n * This allows artifacts of rendering at tile edges to be ignored.\n * Supported data should be wider and taller than the tile size by a value of `2 x gutter`.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Tile projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"./Source.js\").State} [state] The source state.\n * @property {boolean} [wrapX=false] Render tiles beyond the antimeridian.\n * @property {number} [transition] Transition time when fading in new tiles (in milliseconds).\n * @property {number} [bandCount=4] Number of bands represented in the data.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @classdesc\n * A source for typed array data tiles.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\n\nclass DataTileSource extends TileSource {\n  /**\n   * @param {Options} options DataTile source options.\n   */\n  constructor(options) {\n    const projection = options.projection === undefined ? 'EPSG:3857' : options.projection;\n    let tileGrid = options.tileGrid;\n\n    if (tileGrid === undefined && projection) {\n      tileGrid = createXYZ({\n        extent: extentFromProjection(projection),\n        maxResolution: options.maxResolution,\n        maxZoom: options.maxZoom,\n        minZoom: options.minZoom,\n        tileSize: options.tileSize\n      });\n    }\n\n    super({\n      cacheSize: 0.1,\n      // don't cache on the source\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: projection,\n      tileGrid: tileGrid,\n      opaque: options.opaque,\n      state: options.state,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate: options.interpolate\n    });\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;\n    /**\n     * @private\n     * @type {import('../size.js').Size|null}\n     */\n\n    this.tileSize_ = options.tileSize ? toSize(options.tileSize) : null;\n    /**\n     * @private\n     * @type {Array<import('../size.js').Size>|null}\n     */\n\n    this.tileSizes_ = null;\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n\n    this.tileLoadingKeys_ = {};\n    /**\n     * @private\n     */\n\n    this.loader_ = options.loader;\n    this.handleTileChange_ = this.handleTileChange_.bind(this);\n    /**\n     * @type {number}\n     */\n\n    this.bandCount = options.bandCount === undefined ? 4 : options.bandCount; // assume RGBA if undefined\n\n    /**\n     * @private\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n\n    this.tileGridForProjection_ = {};\n    /**\n     * @private\n     * @type {!Object<string, import(\"../TileCache.js\").default>}\n     */\n\n    this.tileCacheForProjection_ = {};\n  }\n  /**\n   * Set the source tile sizes.  The length of the array is expected to match the number of\n   * levels in the tile grid.\n   * @protected\n   * @param {Array<import('../size.js').Size>} tileSizes An array of tile sizes.\n   */\n\n\n  setTileSizes(tileSizes) {\n    this.tileSizes_ = tileSizes;\n  }\n  /**\n   * Get the source tile size at the given zoom level.  This may be different than the rendered tile\n   * size.\n   * @protected\n   * @param {number} z Tile zoom level.\n   * @return {import('../size.js').Size} The source tile size.\n   */\n\n\n  getTileSize(z) {\n    if (this.tileSizes_) {\n      return this.tileSizes_[z];\n    }\n\n    if (this.tileSize_) {\n      return this.tileSize_;\n    }\n\n    const tileGrid = this.getTileGrid();\n    return tileGrid ? toSize(tileGrid.getTileSize(z)) : [256, 256];\n  }\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   */\n\n\n  getGutterForProjection(projection) {\n    const thisProj = this.getProjection();\n\n    if (!thisProj || equivalent(thisProj, projection)) {\n      return this.gutter_;\n    }\n\n    return 0;\n  }\n  /**\n   * @param {Loader} loader The data loader.\n   * @protected\n   */\n\n\n  setLoader(loader) {\n    this.loader_ = loader;\n  }\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../proj/Projection.js\").default} targetProj The output projection.\n   * @param {import(\"../proj/Projection.js\").default} sourceProj The input projection.\n   * @return {!DataTile} Tile.\n   */\n\n\n  getReprojTile_(z, x, y, targetProj, sourceProj) {\n    const cache = this.getTileCacheForProjection(targetProj);\n    const tileCoordKey = getKeyZXY(z, x, y);\n\n    if (cache.containsKey(tileCoordKey)) {\n      const tile = cache.get(tileCoordKey);\n\n      if (tile && tile.key == this.getKey()) {\n        return tile;\n      }\n    }\n\n    const tileGrid = this.getTileGrid();\n    const reprojTilePixelRatio = Math.max.apply(null, tileGrid.getResolutions().map((r, z) => {\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const textureSize = this.getTileSize(z);\n      return Math.max(textureSize[0] / tileSize[0], textureSize[1] / tileSize[1]);\n    }));\n    const sourceTileGrid = this.getTileGridForProjection(sourceProj);\n    const targetTileGrid = this.getTileGridForProjection(targetProj);\n    const tileCoord = [z, x, y];\n    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, targetProj);\n    const options = Object.assign({\n      sourceProj,\n      sourceTileGrid,\n      targetProj,\n      targetTileGrid,\n      tileCoord,\n      wrappedTileCoord,\n      pixelRatio: reprojTilePixelRatio,\n      gutter: this.getGutterForProjection(sourceProj),\n      getTileFunction: (z, x, y, pixelRatio) => this.getTile(z, x, y, pixelRatio, sourceProj)\n    }, this.tileOptions);\n    const newTile = new ReprojDataTile(options);\n    newTile.key = this.getKey();\n    return newTile;\n  }\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!DataTile} Tile.\n   */\n\n\n  getTile(z, x, y, pixelRatio, projection) {\n    const sourceProjection = this.getProjection();\n\n    if (sourceProjection && projection && !equivalent(sourceProjection, projection)) {\n      return this.getReprojTile_(z, x, y, projection, sourceProjection);\n    }\n\n    const size = this.getTileSize(z);\n    const tileCoordKey = getKeyZXY(z, x, y);\n\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      return this.tileCache.get(tileCoordKey);\n    }\n\n    const sourceLoader = this.loader_;\n\n    function loader() {\n      return toPromise(function () {\n        return sourceLoader(z, x, y);\n      });\n    }\n\n    const options = Object.assign({\n      tileCoord: [z, x, y],\n      loader: loader,\n      size: size\n    }, this.tileOptions);\n    const tile = new DataTile(options);\n    tile.key = this.getKey();\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange_);\n    this.tileCache.set(tileCoordKey, tile);\n    return tile;\n  }\n  /**\n   * Handle tile change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   */\n\n\n  handleTileChange_(event) {\n    const tile =\n    /** @type {import(\"../Tile.js\").default} */\n    event.target;\n    const uid = getUid(tile);\n    const tileState = tile.getState();\n    let type;\n\n    if (tileState == TileState.LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type = tileState == TileState.ERROR ? TileEventType.TILELOADERROR : tileState == TileState.LOADED ? TileEventType.TILELOADEND : undefined;\n    }\n\n    if (type) {\n      this.dispatchEvent(new TileSourceEvent(type, tile));\n    }\n  }\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n\n\n  getTileGridForProjection(projection) {\n    const thisProj = this.getProjection();\n\n    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\n      return this.tileGrid;\n    }\n\n    const projKey = getUid(projection);\n\n    if (!(projKey in this.tileGridForProjection_)) {\n      this.tileGridForProjection_[projKey] = getTileGridForProjection(projection);\n    }\n\n    return this.tileGridForProjection_[projKey];\n  }\n  /**\n   * Sets the tile grid to use when reprojecting the tiles to the given\n   * projection instead of the default tile grid for the projection.\n   *\n   * This can be useful when the default tile grid cannot be created\n   * (e.g. projection has no extent defined) or\n   * for optimization reasons (custom tile size, resolutions, ...).\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n   * @api\n   */\n\n\n  setTileGridForProjection(projection, tilegrid) {\n    const proj = getProjection(projection);\n\n    if (proj) {\n      const projKey = getUid(proj);\n\n      if (!(projKey in this.tileGridForProjection_)) {\n        this.tileGridForProjection_[projKey] = tilegrid;\n      }\n    }\n  }\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../TileCache.js\").default} Tile cache.\n   */\n\n\n  getTileCacheForProjection(projection) {\n    const thisProj = this.getProjection();\n\n    if (!thisProj || equivalent(thisProj, projection)) {\n      return this.tileCache;\n    }\n\n    const projKey = getUid(projection);\n\n    if (!(projKey in this.tileCacheForProjection_)) {\n      this.tileCacheForProjection_[projKey] = new TileCache(0.1); // don't cache\n    }\n\n    return this.tileCacheForProjection_[projKey];\n  }\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n\n\n  expireCache(projection, usedTiles) {\n    const usedTileCache = this.getTileCacheForProjection(projection);\n    this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});\n\n    for (const id in this.tileCacheForProjection_) {\n      const tileCache = this.tileCacheForProjection_[id];\n      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\n    }\n  }\n\n  clear() {\n    super.clear();\n\n    for (const id in this.tileCacheForProjection_) {\n      this.tileCacheForProjection_[id].clear();\n    }\n  }\n\n}\n\nexport default DataTileSource;","map":null,"metadata":{},"sourceType":"module"}