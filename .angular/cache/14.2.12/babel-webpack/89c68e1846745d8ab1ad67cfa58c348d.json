{"ast":null,"code":"/**\n * @module resample\n */\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\n\n\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map(array => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[cy * inWidth + cx];\n        newArray[y * outWidth + x] = value;\n      }\n    }\n\n    return newArray;\n  });\n} // simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\n\nfunction lerp(v0, v1, t) {\n  return (1 - t) * v0 + t * v1;\n}\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\n\n\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map(array => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), inHeight - 1);\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), inWidth - 1);\n        const ll = array[yl * inWidth + xl];\n        const hl = array[yl * inWidth + xh];\n        const lh = array[yh * inWidth + xl];\n        const hh = array[yh * inWidth + xh];\n        const value = lerp(lerp(ll, hl, tx), lerp(lh, hh, tx), rawY % 1);\n        newArray[y * outWidth + x] = value;\n      }\n    }\n\n    return newArray;\n  });\n}\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\n\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\n\nexport function resampleNearestInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[cy * inWidth * samples + cx * samples + i];\n        newArray[y * outWidth * samples + x * samples + i] = value;\n      }\n    }\n  }\n\n  return newArray;\n}\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\n\nexport function resampleBilinearInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), inHeight - 1);\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), inWidth - 1);\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[yl * inWidth * samples + xl * samples + i];\n        const hl = valueArray[yl * inWidth * samples + xh * samples + i];\n        const lh = valueArray[yh * inWidth * samples + xl * samples + i];\n        const hh = valueArray[yh * inWidth * samples + xh * samples + i];\n        const value = lerp(lerp(ll, hl, tx), lerp(lh, hh, tx), rawY % 1);\n        newArray[y * outWidth * samples + x * samples + i] = value;\n      }\n    }\n  }\n\n  return newArray;\n}\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\n\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples);\n\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples);\n\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}