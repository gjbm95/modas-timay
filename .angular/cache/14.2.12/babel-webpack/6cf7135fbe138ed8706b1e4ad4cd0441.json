{"ast":null,"code":"/**\n * @module ol/reproj/DataTile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport DataTile, { asArrayLike, asImageLike, toArray } from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceExtentResolution, canvasPool, render as renderReprojected } from '../reproj.js';\nimport { clamp } from '../math.js';\nimport { createCanvasContext2D, releaseCanvas } from '../dom.js';\nimport { getArea, getIntersection } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @typedef {function(number, number, number, number) : import(\"../DataTile.js\").default} TileGetter\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n * @property {import(\"../proj/Projection.js\").default} targetProj Target projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n * @property {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n * @property {import(\"../tilecoord.js\").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.\n * @property {number} pixelRatio Pixel ratio.\n * @property {number} gutter Gutter of the source tiles.\n * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {number} [errorThreshold] Acceptable reprojection error (in px).\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected data tile.\n * See {@link module:ol/source/DataTile~DataTileSource}.\n *\n */\n\nclass ReprojDataTile extends DataTile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    super({\n      tileCoord: options.tileCoord,\n      loader: () => Promise.resolve(new Uint8Array(4)),\n      interpolate: options.interpolate,\n      transition: options.transition\n    });\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.pixelRatio_ = options.pixelRatio;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.gutter_ = options.gutter;\n    /**\n     * @type {import(\"../DataTile.js\").Data}\n     * @private\n     */\n\n    this.reprojData_ = null;\n    /**\n     * @type {Error}\n     * @private\n     */\n\n    this.reprojError_ = null;\n    /**\n     * @type {import('../size.js').Size}\n     * @private\n     */\n\n    this.reprojSize_ = undefined;\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n\n    this.sourceTileGrid_ = options.sourceTileGrid;\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n\n    this.targetTileGrid_ = options.targetTileGrid;\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n\n    this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;\n    /**\n     * @private\n     * @type {!Array<DataTile>}\n     */\n\n    this.sourceTiles_ = [];\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n\n    this.sourcesListenerKeys_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.sourceZ_ = 0;\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n    const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProj = options.sourceProj;\n    const sourceProjExtent = sourceProj.getExtent();\n\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = this.targetTileGrid_.getResolution(this.wrappedTileCoord_[0]);\n    const targetProj = options.targetProj;\n    const sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels = options.errorThreshold !== undefined ? options.errorThreshold : ERROR_THRESHOLD;\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n\n    this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(sourceExtent, this.sourceZ_);\n      const getTile = options.getTileFunction;\n\n      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);\n\n          if (tile) {\n            this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n  /**\n   * Get the tile size.\n   * @return {import('../size.js').Size} Tile size.\n   */\n\n\n  getSize() {\n    return this.reprojSize_;\n  }\n  /**\n   * Get the data for the tile.\n   * @return {import(\"../DataTile.js\").Data} Tile data.\n   */\n\n\n  getData() {\n    return this.reprojData_;\n  }\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   */\n\n\n  getError() {\n    return this.reprojError_;\n  }\n  /**\n   * @private\n   */\n\n\n  reproject_() {\n    const dataSources = [];\n    this.sourceTiles_.forEach(tile => {\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n\n      const size = tile.getSize();\n      const gutter = this.gutter_;\n      /**\n       * @type {import(\"../DataTile.js\").ArrayLike}\n       */\n\n      let tileData;\n      const arrayData = asArrayLike(tile.getData());\n\n      if (arrayData) {\n        tileData = arrayData;\n      } else {\n        tileData = toArray(asImageLike(tile.getData()));\n      }\n\n      const pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];\n      const isFloat = tileData instanceof Float32Array;\n      const pixelCount = pixelSize[0] * pixelSize[1];\n      const DataType = isFloat ? Float32Array : Uint8Array;\n      const tileDataR = new DataType(tileData.buffer);\n      const bytesPerElement = DataType.BYTES_PER_ELEMENT;\n      const bytesPerPixel = bytesPerElement * tileDataR.length / pixelCount;\n      const bytesPerRow = tileDataR.byteLength / pixelSize[1];\n      const bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);\n      const packedLength = pixelCount * bandCount;\n      let packedData = tileDataR;\n\n      if (tileDataR.length !== packedLength) {\n        packedData = new DataType(packedLength);\n        let dataIndex = 0;\n        let rowOffset = 0;\n        const colCount = pixelSize[0] * bandCount;\n\n        for (let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {\n          for (let colIndex = 0; colIndex < colCount; ++colIndex) {\n            packedData[dataIndex++] = tileDataR[rowOffset + colIndex];\n          }\n\n          rowOffset += bytesPerRow / bytesPerElement;\n        }\n      }\n\n      dataSources.push({\n        extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n        data: new Uint8Array(packedData.buffer),\n        dataType: DataType,\n        bytesPerPixel: bytesPerPixel,\n        pixelSize: pixelSize\n      });\n    });\n    this.sourceTiles_.length = 0;\n\n    if (dataSources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const targetWidth = typeof size === 'number' ? size : size[0];\n      const targetHeight = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n      let dataR, dataU;\n      const bytesPerPixel = dataSources[0].bytesPerPixel;\n      const reprojs = Math.ceil(bytesPerPixel / 3);\n\n      for (let reproj = reprojs - 1; reproj >= 0; --reproj) {\n        const sources = [];\n\n        for (let i = 0, len = dataSources.length; i < len; ++i) {\n          const dataSource = dataSources[i];\n          const buffer = dataSource.data;\n          const pixelSize = dataSource.pixelSize;\n          const width = pixelSize[0];\n          const height = pixelSize[1];\n          const context = createCanvasContext2D(width, height, canvasPool);\n          const imageData = context.createImageData(width, height);\n          const data = imageData.data;\n          let offset = reproj * 3;\n\n          for (let j = 0, len = data.length; j < len; j += 4) {\n            data[j] = buffer[offset];\n            data[j + 1] = buffer[offset + 1];\n            data[j + 2] = buffer[offset + 2];\n            data[j + 3] = 255;\n            offset += bytesPerPixel;\n          }\n\n          context.putImageData(imageData, 0, 0);\n          sources.push({\n            extent: dataSource.extent,\n            image: context.canvas\n          });\n        }\n\n        const canvas = renderReprojected(targetWidth, targetHeight, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, false, false);\n\n        for (let i = 0, len = sources.length; i < len; ++i) {\n          const canvas = sources[i].image;\n          const context = canvas.getContext('2d');\n          releaseCanvas(context);\n          canvasPool.push(context.canvas);\n        }\n\n        const context = canvas.getContext('2d');\n        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n        releaseCanvas(context);\n        canvasPool.push(canvas);\n\n        if (!dataR) {\n          dataU = new Uint8Array(bytesPerPixel * imageData.width * imageData.height);\n          dataR = new dataSources[0].dataType(dataU.buffer);\n        }\n\n        const data = imageData.data;\n        let offset = reproj * 3;\n\n        for (let i = 0, len = data.length; i < len; i += 4) {\n          if (data[i + 3] === 255) {\n            dataU[offset] = data[i];\n            dataU[offset + 1] = data[i + 1];\n            dataU[offset + 2] = data[i + 2];\n          } else {\n            dataU[offset] = 0;\n            dataU[offset + 1] = 0;\n            dataU[offset + 2] = 0;\n          }\n\n          offset += bytesPerPixel;\n        }\n      }\n\n      this.reprojData_ = dataR;\n      this.reprojSize_ = [Math.round(targetWidth * this.pixelRatio_), Math.round(targetHeight * this.pixelRatio_)];\n      this.state = TileState.LOADED;\n    }\n\n    this.changed();\n  }\n  /**\n   * Load not yet loaded URI.\n   */\n\n\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n\n    this.state = TileState.LOADING;\n    this.changed();\n    let leftToLoad = 0;\n    this.sourcesListenerKeys_ = [];\n    this.sourceTiles_.forEach(tile => {\n      const state = tile.getState();\n\n      if (state !== TileState.IDLE && state !== TileState.LOADING) {\n        return;\n      }\n\n      leftToLoad++;\n      const sourceListenKey = listen(tile, EventType.CHANGE, function () {\n        const state = tile.getState();\n\n        if (state == TileState.LOADED || state == TileState.ERROR || state == TileState.EMPTY) {\n          unlistenByKey(sourceListenKey);\n          leftToLoad--;\n\n          if (leftToLoad === 0) {\n            this.unlistenSources_();\n            this.reproject_();\n          }\n        }\n      }, this);\n      this.sourcesListenerKeys_.push(sourceListenKey);\n    });\n\n    if (leftToLoad === 0) {\n      setTimeout(this.reproject_.bind(this), 0);\n    } else {\n      this.sourceTiles_.forEach(function (tile) {\n        const state = tile.getState();\n\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n\n}\n\nexport default ReprojDataTile;","map":null,"metadata":{},"sourceType":"module"}