{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Usuario/Documents/Trabajos para empresas/Modas Timay Fashion/Pagina web/modas-timay/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/** @module geotiff */\nimport GeoTIFFImage from './geotiffimage.js';\nimport DataView64 from './dataview64.js';\nimport DataSlice from './dataslice.js';\nimport Pool from './pool.js';\nimport { makeRemoteSource } from './source/remote.js';\nimport { makeBufferSource } from './source/arraybuffer.js';\nimport { makeFileReaderSource } from './source/filereader.js';\nimport { makeFileSource } from './source/file.js';\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals.js';\nimport { writeGeotiff } from './geotiffwriter.js';\nimport * as globals from './globals.js';\nimport * as rgb from './rgb.js';\nimport { getDecoder, addDecoder } from './compression/index.js';\nimport { setLogger } from './logging.js';\nexport { globals };\nexport { rgb };\nexport { default as BaseDecoder } from './compression/basedecoder.js';\nexport { getDecoder, addDecoder };\nexport { setLogger };\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE:\n    case fieldTypes.ASCII:\n    case fieldTypes.SBYTE:\n    case fieldTypes.UNDEFINED:\n      return 1;\n\n    case fieldTypes.SHORT:\n    case fieldTypes.SSHORT:\n      return 2;\n\n    case fieldTypes.LONG:\n    case fieldTypes.SLONG:\n    case fieldTypes.FLOAT:\n    case fieldTypes.IFD:\n      return 4;\n\n    case fieldTypes.RATIONAL:\n    case fieldTypes.SRATIONAL:\n    case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8:\n    case fieldTypes.SLONG8:\n    case fieldTypes.IFD8:\n      return 8;\n\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = rawGeoKeyDirectory[i + 1] ? fieldTagNames[rawGeoKeyDirectory[i + 1]] : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n    let value = null;\n\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n\n    geoKeyDirectory[key] = value;\n  }\n\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE:\n    case fieldTypes.ASCII:\n    case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count);\n      readMethod = dataSlice.readUint8;\n      break;\n\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count);\n      readMethod = dataSlice.readInt8;\n      break;\n\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count);\n      readMethod = dataSlice.readUint16;\n      break;\n\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count);\n      readMethod = dataSlice.readInt16;\n      break;\n\n    case fieldTypes.LONG:\n    case fieldTypes.IFD:\n      values = new Uint32Array(count);\n      readMethod = dataSlice.readUint32;\n      break;\n\n    case fieldTypes.SLONG:\n      values = new Int32Array(count);\n      readMethod = dataSlice.readInt32;\n      break;\n\n    case fieldTypes.LONG8:\n    case fieldTypes.IFD8:\n      values = new Array(count);\n      readMethod = dataSlice.readUint64;\n      break;\n\n    case fieldTypes.SLONG8:\n      values = new Array(count);\n      readMethod = dataSlice.readInt64;\n      break;\n\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2);\n      readMethod = dataSlice.readUint32;\n      break;\n\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2);\n      readMethod = dataSlice.readInt32;\n      break;\n\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count);\n      readMethod = dataSlice.readFloat32;\n      break;\n\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count);\n      readMethod = dataSlice.readFloat64;\n      break;\n\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  } // normal fields\n\n\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(dataSlice, offset + i * fieldTypeLength);\n    }\n  } else {\n    // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(dataSlice, offset + i * fieldTypeLength);\n      values[i + 1] = readMethod.call(dataSlice, offset + (i * fieldTypeLength + 4));\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n\n  return values;\n}\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\n\n\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n\n}\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\n\n\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n   */\n  readRasters(options = {}) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        window: imageWindow,\n        width,\n        height\n      } = options;\n      let {\n        resX,\n        resY,\n        bbox\n      } = options;\n      const firstImage = yield _this.getImage();\n      let usedImage = firstImage;\n      const imageCount = yield _this.getImageCount();\n      const imgBBox = firstImage.getBoundingBox();\n\n      if (imageWindow && bbox) {\n        throw new Error('Both \"bbox\" and \"window\" passed.');\n      } // if width/height is passed, transform it to resolution\n\n\n      if (width || height) {\n        // if we have an image window (pixel coordinates), transform it to a BBox\n        // using the origin/resolution of the first image.\n        if (imageWindow) {\n          const [oX, oY] = firstImage.getOrigin();\n          const [rX, rY] = firstImage.getResolution();\n          bbox = [oX + imageWindow[0] * rX, oY + imageWindow[1] * rY, oX + imageWindow[2] * rX, oY + imageWindow[3] * rY];\n        } // if we have a bbox (or calculated one)\n\n\n        const usedBBox = bbox || imgBBox;\n\n        if (width) {\n          if (resX) {\n            throw new Error('Both width and resX passed');\n          }\n\n          resX = (usedBBox[2] - usedBBox[0]) / width;\n        }\n\n        if (height) {\n          if (resY) {\n            throw new Error('Both width and resY passed');\n          }\n\n          resY = (usedBBox[3] - usedBBox[1]) / height;\n        }\n      } // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n\n\n      if (resX || resY) {\n        const allImages = [];\n\n        for (let i = 0; i < imageCount; ++i) {\n          const image = yield _this.getImage(i);\n          const {\n            SubfileType: subfileType,\n            NewSubfileType: newSubfileType\n          } = image.fileDirectory;\n\n          if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n            allImages.push(image);\n          }\n        }\n\n        allImages.sort((a, b) => a.getWidth() - b.getWidth());\n\n        for (let i = 0; i < allImages.length; ++i) {\n          const image = allImages[i];\n          const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n          const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n          usedImage = image;\n\n          if (resX && resX > imgResX || resY && resY > imgResY) {\n            break;\n          }\n        }\n      }\n\n      let wnd = imageWindow;\n\n      if (bbox) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n        wnd = [Math.round((bbox[0] - oX) / imageResX), Math.round((bbox[1] - oY) / imageResY), Math.round((bbox[2] - oX) / imageResX), Math.round((bbox[3] - oY) / imageResY)];\n        wnd = [Math.min(wnd[0], wnd[2]), Math.min(wnd[1], wnd[3]), Math.max(wnd[0], wnd[2]), Math.max(wnd[1], wnd[3])];\n      }\n\n      return usedImage.readRasters({ ...options,\n        window: wnd\n      });\n    })();\n  }\n\n}\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\n\n\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  getSlice(offset, size) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const fallbackSize = _this2.bigTiff ? 4048 : 1024;\n      return new DataSlice((yield _this2.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize\n      }]))[0], offset, _this2.littleEndian, _this2.bigTiff);\n    })();\n  }\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n\n\n  parseFileDirectoryAt(offset) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const entrySize = _this3.bigTiff ? 20 : 12;\n      const offsetSize = _this3.bigTiff ? 8 : 2;\n      let dataSlice = yield _this3.getSlice(offset);\n      const numDirEntries = _this3.bigTiff ? dataSlice.readUint64(offset) : dataSlice.readUint16(offset); // if the slice does not cover the whole IFD, request a bigger slice, where the\n      // whole IFD fits: num of entries + n x tag length + offset to next IFD\n\n      const byteSize = numDirEntries * entrySize + (_this3.bigTiff ? 16 : 6);\n\n      if (!dataSlice.covers(offset, byteSize)) {\n        dataSlice = yield _this3.getSlice(offset, byteSize);\n      }\n\n      const fileDirectory = {}; // loop over the IFD and create a file directory object\n\n      let i = offset + (_this3.bigTiff ? 8 : 2);\n\n      for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n        const fieldTag = dataSlice.readUint16(i);\n        const fieldType = dataSlice.readUint16(i + 2);\n        const typeCount = _this3.bigTiff ? dataSlice.readUint64(i + 4) : dataSlice.readUint32(i + 4);\n        let fieldValues;\n        let value;\n        const fieldTypeLength = getFieldTypeLength(fieldType);\n        const valueOffset = i + (_this3.bigTiff ? 12 : 8); // check whether the value is directly encoded in the tag or refers to a\n        // different external byte range\n\n        if (fieldTypeLength * typeCount <= (_this3.bigTiff ? 8 : 4)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n        } else {\n          // resolve the reference to the actual byte range\n          const actualOffset = dataSlice.readOffset(valueOffset);\n          const length = getFieldTypeLength(fieldType) * typeCount; // check, whether we actually cover the referenced byte range; if not,\n          // request a new slice of bytes to read from it\n\n          if (dataSlice.covers(actualOffset, length)) {\n            fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n          } else {\n            const fieldDataSlice = yield _this3.getSlice(actualOffset, length);\n            fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n          }\n        } // unpack single values from the array\n\n\n        if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1 && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n          value = fieldValues[0];\n        } else {\n          value = fieldValues;\n        } // write the tags value to the file directly\n\n\n        fileDirectory[fieldTagNames[fieldTag]] = value;\n      }\n\n      const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n      const nextIFDByteOffset = dataSlice.readOffset(offset + offsetSize + entrySize * numDirEntries);\n      return new ImageFileDirectory(fileDirectory, geoKeyDirectory, nextIFDByteOffset);\n    })();\n  }\n\n  requestIFD(index) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      // see if we already have that IFD index requested.\n      if (_this4.ifdRequests[index]) {\n        // attach to an already requested IFD\n        return _this4.ifdRequests[index];\n      } else if (index === 0) {\n        // special case for index 0\n        _this4.ifdRequests[index] = _this4.parseFileDirectoryAt(_this4.firstIFDOffset);\n        return _this4.ifdRequests[index];\n      } else if (!_this4.ifdRequests[index - 1]) {\n        // if the previous IFD was not yet loaded, load that one first\n        // this is the recursive call.\n        try {\n          _this4.ifdRequests[index - 1] = _this4.requestIFD(index - 1);\n        } catch (e) {\n          // if the previous one already was an index error, rethrow\n          // with the current index\n          if (e instanceof GeoTIFFImageIndexError) {\n            throw new GeoTIFFImageIndexError(index);\n          } // rethrow anything else\n\n\n          throw e;\n        }\n      } // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n      // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n\n\n      _this4.ifdRequests[index] = _asyncToGenerator(function* () {\n        const previousIfd = yield _this4.ifdRequests[index - 1];\n\n        if (previousIfd.nextIFDByteOffset === 0) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n\n        return _this4.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n      })();\n      return _this4.ifdRequests[index];\n    })();\n  }\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n\n\n  getImage(index = 0) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const ifd = yield _this5.requestIFD(index);\n      return new GeoTIFFImage(ifd.fileDirectory, ifd.geoKeyDirectory, _this5.dataView, _this5.littleEndian, _this5.cache, _this5.source);\n    })();\n  }\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n\n\n  getImageCount() {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      let index = 0; // loop until we run out of IFDs\n\n      let hasNext = true;\n\n      while (hasNext) {\n        try {\n          yield _this6.requestIFD(index);\n          ++index;\n        } catch (e) {\n          if (e instanceof GeoTIFFImageIndexError) {\n            hasNext = false;\n          } else {\n            throw e;\n          }\n        }\n      }\n\n      return index;\n    })();\n  }\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n\n\n  getGhostValues() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const offset = _this7.bigTiff ? 16 : 8;\n\n      if (_this7.ghostValues) {\n        return _this7.ghostValues;\n      }\n\n      const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n      const heuristicAreaSize = detectionString.length + 100;\n      let slice = yield _this7.getSlice(offset, heuristicAreaSize);\n\n      if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n        const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n        const firstLine = valuesString.split('\\n')[0];\n        const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n\n        if (metadataSize > heuristicAreaSize) {\n          slice = yield _this7.getSlice(offset, metadataSize);\n        }\n\n        const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n        _this7.ghostValues = {};\n        fullString.split('\\n').filter(line => line.length > 0).map(line => line.split('=')).forEach(([key, value]) => {\n          _this7.ghostValues[key] = value;\n        });\n      }\n\n      return _this7.ghostValues;\n    })();\n  }\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n\n\n  static fromSource(source, options, signal) {\n    return _asyncToGenerator(function* () {\n      const headerData = (yield source.fetch([{\n        offset: 0,\n        length: 1024\n      }], signal))[0];\n      const dataView = new DataView64(headerData);\n      const BOM = dataView.getUint16(0, 0);\n      let littleEndian;\n\n      if (BOM === 0x4949) {\n        littleEndian = true;\n      } else if (BOM === 0x4D4D) {\n        littleEndian = false;\n      } else {\n        throw new TypeError('Invalid byte order value.');\n      }\n\n      const magicNumber = dataView.getUint16(2, littleEndian);\n      let bigTiff;\n\n      if (magicNumber === 42) {\n        bigTiff = false;\n      } else if (magicNumber === 43) {\n        bigTiff = true;\n        const offsetByteSize = dataView.getUint16(4, littleEndian);\n\n        if (offsetByteSize !== 8) {\n          throw new Error('Unsupported offset byte-size.');\n        }\n      } else {\n        throw new TypeError('Invalid magic number.');\n      }\n\n      const firstIFDOffset = bigTiff ? dataView.getUint64(8, littleEndian) : dataView.getUint32(4, littleEndian);\n      return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n    })();\n  }\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n\n\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n\n    return false;\n  }\n\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\n\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  parseFileDirectoriesPerFile() {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      const requests = [_this8.mainFile.parseFileDirectoryAt(_this8.mainFile.firstIFDOffset)].concat(_this8.overviewFiles.map(file => file.parseFileDirectoryAt(file.firstIFDOffset)));\n      _this8.fileDirectoriesPerFile = yield Promise.all(requests);\n      return _this8.fileDirectoriesPerFile;\n    })();\n  }\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n\n\n  getImage(index = 0) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this9.getImageCount();\n      yield _this9.parseFileDirectoriesPerFile();\n      let visited = 0;\n      let relativeIndex = 0;\n\n      for (let i = 0; i < _this9.imageFiles.length; i++) {\n        const imageFile = _this9.imageFiles[i];\n\n        for (let ii = 0; ii < _this9.imageCounts[i]; ii++) {\n          if (index === visited) {\n            const ifd = yield imageFile.requestIFD(relativeIndex);\n            return new GeoTIFFImage(ifd.fileDirectory, ifd.geoKeyDirectory, imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source);\n          }\n\n          visited++;\n          relativeIndex++;\n        }\n\n        relativeIndex = 0;\n      }\n\n      throw new RangeError('Invalid image index');\n    })();\n  }\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n\n\n  getImageCount() {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this10.imageCount !== null) {\n        return _this10.imageCount;\n      }\n\n      const requests = [_this10.mainFile.getImageCount()].concat(_this10.overviewFiles.map(file => file.getImageCount()));\n      _this10.imageCounts = yield Promise.all(requests);\n      _this10.imageCount = _this10.imageCounts.reduce((count, ifds) => count + ifds, 0);\n      return _this10.imageCount;\n    })();\n  }\n\n}\n\nexport { MultiGeoTIFF };\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\n\nexport function fromUrl(_x) {\n  return _fromUrl.apply(this, arguments);\n}\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\n\nfunction _fromUrl() {\n  _fromUrl = _asyncToGenerator(function* (url, options = {}, signal) {\n    return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n  });\n  return _fromUrl.apply(this, arguments);\n}\n\nexport function fromArrayBuffer(_x2, _x3) {\n  return _fromArrayBuffer.apply(this, arguments);\n}\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\n\nfunction _fromArrayBuffer() {\n  _fromArrayBuffer = _asyncToGenerator(function* (arrayBuffer, signal) {\n    return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n  });\n  return _fromArrayBuffer.apply(this, arguments);\n}\n\nexport function fromFile(_x4, _x5) {\n  return _fromFile.apply(this, arguments);\n}\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\n\nfunction _fromFile() {\n  _fromFile = _asyncToGenerator(function* (path, signal) {\n    return GeoTIFF.fromSource(makeFileSource(path), signal);\n  });\n  return _fromFile.apply(this, arguments);\n}\n\nexport function fromBlob(_x6, _x7) {\n  return _fromBlob.apply(this, arguments);\n}\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\n\nfunction _fromBlob() {\n  _fromBlob = _asyncToGenerator(function* (blob, signal) {\n    return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n  });\n  return _fromBlob.apply(this, arguments);\n}\n\nexport function fromUrls(_x8) {\n  return _fromUrls.apply(this, arguments);\n}\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\n\nfunction _fromUrls() {\n  _fromUrls = _asyncToGenerator(function* (mainUrl, overviewUrls = [], options = {}, signal) {\n    const mainFile = yield GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n    const overviewFiles = yield Promise.all(overviewUrls.map(url => GeoTIFF.fromSource(makeRemoteSource(url, options))));\n    return new MultiGeoTIFF(mainFile, overviewFiles);\n  });\n  return _fromUrls.apply(this, arguments);\n}\n\nexport function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\nexport { Pool };\nexport { GeoTIFFImage };","map":null,"metadata":{},"sourceType":"module"}