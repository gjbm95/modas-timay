{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Usuario/Documents/Trabajos para empresas/Modas Timay Fashion/Pagina web/modas-timay/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n\n\n  fetch(slices, signal) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // if we allow multi-ranges, split the incoming request into that many sub-requests\n      // and join them afterwards\n      if (_this.maxRanges >= slices.length) {\n        return _this.fetchSlices(slices, signal);\n      } else if (_this.maxRanges > 0 && slices.length > 1) {// TODO: split into multiple multi-range requests\n        // const subSlicesRequests = [];\n        // for (let i = 0; i < slices.length; i += this.maxRanges) {\n        //   subSlicesRequests.push(\n        //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n        //   );\n        // }\n        // return (await Promise.all(subSlicesRequests)).flat();\n      } // otherwise make a single request for each slice\n\n\n      return Promise.all(slices.map(slice => _this.fetchSlice(slice, signal)));\n    })();\n  }\n\n  fetchSlices(slices, signal) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const response = yield _this2.client.request({\n        headers: { ..._this2.headers,\n          Range: `bytes=${slices.map(({\n            offset,\n            length\n          }) => `${offset}-${offset + length}`).join(',')}`\n        },\n        signal\n      });\n\n      if (!response.ok) {\n        throw new Error('Error fetching data.');\n      } else if (response.status === 206) {\n        const {\n          type,\n          params\n        } = parseContentType(response.getHeader('content-type'));\n\n        if (type === 'multipart/byteranges') {\n          const byteRanges = parseByteRanges(yield response.getData(), params.boundary);\n          _this2._fileSize = byteRanges[0].fileSize || null;\n          return byteRanges;\n        }\n\n        const data = yield response.getData();\n        const {\n          start,\n          end,\n          total\n        } = parseContentRange(response.getHeader('content-range'));\n        _this2._fileSize = total || null;\n        const first = [{\n          data,\n          offset: start,\n          length: end - start\n        }];\n\n        if (slices.length > 1) {\n          // we requested more than one slice, but got only the first\n          // unfortunately, some HTTP Servers don't support multi-ranges\n          // and return only the first\n          // get the rest of the slices and fetch them iteratively\n          const others = yield Promise.all(slices.slice(1).map(slice => _this2.fetchSlice(slice, signal)));\n          return first.concat(others);\n        }\n\n        return first;\n      } else {\n        if (!_this2.allowFullFile) {\n          throw new Error('Server responded with full file');\n        }\n\n        const data = yield response.getData();\n        _this2._fileSize = data.byteLength;\n        return [{\n          data,\n          offset: 0,\n          length: data.byteLength\n        }];\n      }\n    })();\n  }\n\n  fetchSlice(slice, signal) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        offset,\n        length\n      } = slice;\n      const response = yield _this3.client.request({\n        headers: { ..._this3.headers,\n          Range: `bytes=${offset}-${offset + length}`\n        },\n        signal\n      }); // check the response was okay and if the server actually understands range requests\n\n      if (!response.ok) {\n        throw new Error('Error fetching data.');\n      } else if (response.status === 206) {\n        const data = yield response.getData();\n        const {\n          total\n        } = parseContentRange(response.getHeader('content-range'));\n        _this3._fileSize = total || null;\n        return {\n          data,\n          offset,\n          length\n        };\n      } else {\n        if (!_this3.allowFullFile) {\n          throw new Error('Server responded with full file');\n        }\n\n        const data = yield response.getData();\n        _this3._fileSize = data.byteLength;\n        return {\n          data,\n          offset: 0,\n          length: data.byteLength\n        };\n      }\n    })();\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n\n}\n\nfunction maybeWrapInBlockedSource(source, {\n  blockSize,\n  cacheSize\n}) {\n  if (blockSize === null) {\n    return source;\n  }\n\n  return new BlockedSource(source, {\n    blockSize,\n    cacheSize\n  });\n}\n\nexport function makeFetchSource(url, {\n  headers = {},\n  credentials,\n  maxRanges = 0,\n  allowFullFile = false,\n  ...blockOptions\n} = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\nexport function makeXHRSource(url, {\n  headers = {},\n  maxRanges = 0,\n  allowFullFile = false,\n  ...blockOptions\n} = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\nexport function makeHttpSource(url, {\n  headers = {},\n  maxRanges = 0,\n  allowFullFile = false,\n  ...blockOptions\n} = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n/**\n *\n * @param {string} url\n * @param {object} options\n */\n\nexport function makeRemoteSource(url, {\n  forceXHR = false,\n  ...clientOptions\n} = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n\n  return makeHttpSource(url, clientOptions);\n}","map":null,"metadata":{},"sourceType":"module"}