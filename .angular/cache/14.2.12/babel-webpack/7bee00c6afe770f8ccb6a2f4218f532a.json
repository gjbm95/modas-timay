{"ast":null,"code":"/**\n * @module ol/reproj/Image\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport EventType from '../events/EventType.js';\nimport ImageBase from '../ImageBase.js';\nimport ImageState from '../ImageState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceResolution, render as renderReprojected } from '../reproj.js';\nimport { getCenter, getHeight, getIntersection, getWidth, isEmpty } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @typedef {function(import(\"../extent.js\").Extent, number, number) : import(\"../ImageBase.js\").default} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected image.\n * See {@link module:ol/source/Image~ImageSource}.\n */\n\nclass ReprojImage extends ImageBase {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection (of the data).\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent.\n   * @param {number} targetResolution Target resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {FunctionType} getImageFunction\n   *     Function returning source images (extent, resolution, pixelRatio).\n   * @param {boolean} interpolate Use linear interpolation when resampling.\n   */\n  constructor(sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction, interpolate) {\n    let maxSourceExtent = sourceProj.getExtent();\n\n    if (maxSourceExtent && sourceProj.canWrapX()) {\n      maxSourceExtent = maxSourceExtent.slice();\n      maxSourceExtent[0] = -Infinity;\n      maxSourceExtent[2] = Infinity;\n    }\n\n    let maxTargetExtent = targetProj.getExtent();\n\n    if (maxTargetExtent && targetProj.canWrapX()) {\n      maxTargetExtent = maxTargetExtent.slice();\n      maxTargetExtent[0] = -Infinity;\n      maxTargetExtent[2] = Infinity;\n    }\n\n    const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n    const targetCenter = getCenter(limitedTargetExtent);\n    const sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);\n    const errorThresholdInPixels = ERROR_THRESHOLD;\n    const triangulation = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n    const sourceExtent = triangulation.calculateSourceExtent();\n    const sourceImage = isEmpty(sourceExtent) ? null : getImageFunction(sourceExtent, sourceResolution, pixelRatio);\n    const state = sourceImage ? ImageState.IDLE : ImageState.EMPTY;\n    const sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;\n    super(targetExtent, targetResolution, sourcePixelRatio, state);\n    /**\n     * @private\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n\n    this.targetProj_ = targetProj;\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n\n    this.maxSourceExtent_ = maxSourceExtent;\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n\n    this.triangulation_ = triangulation;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.targetResolution_ = targetResolution;\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n\n    this.targetExtent_ = targetExtent;\n    /**\n     * @private\n     * @type {import(\"../ImageBase.js\").default}\n     */\n\n    this.sourceImage_ = sourceImage;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.sourcePixelRatio_ = sourcePixelRatio;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.interpolate_ = interpolate;\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n\n    this.canvas_ = null;\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n\n    this.sourceListenerKey_ = null;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  disposeInternal() {\n    if (this.state == ImageState.LOADING) {\n      this.unlistenSource_();\n    }\n\n    super.disposeInternal();\n  }\n  /**\n   * @return {HTMLCanvasElement} Image.\n   */\n\n\n  getImage() {\n    return this.canvas_;\n  }\n  /**\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n\n\n  getProjection() {\n    return this.targetProj_;\n  }\n  /**\n   * @private\n   */\n\n\n  reproject_() {\n    const sourceState = this.sourceImage_.getState();\n\n    if (sourceState == ImageState.LOADED) {\n      const width = getWidth(this.targetExtent_) / this.targetResolution_;\n      const height = getHeight(this.targetExtent_) / this.targetResolution_;\n      this.canvas_ = renderReprojected(width, height, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [{\n        extent: this.sourceImage_.getExtent(),\n        image: this.sourceImage_.getImage()\n      }], 0, undefined, this.interpolate_);\n    }\n\n    this.state = sourceState;\n    this.changed();\n  }\n  /**\n   * Load not yet loaded URI.\n   */\n\n\n  load() {\n    if (this.state == ImageState.IDLE) {\n      this.state = ImageState.LOADING;\n      this.changed();\n      const sourceState = this.sourceImage_.getState();\n\n      if (sourceState == ImageState.LOADED || sourceState == ImageState.ERROR) {\n        this.reproject_();\n      } else {\n        this.sourceListenerKey_ = listen(this.sourceImage_, EventType.CHANGE, function (e) {\n          const sourceState = this.sourceImage_.getState();\n\n          if (sourceState == ImageState.LOADED || sourceState == ImageState.ERROR) {\n            this.unlistenSource_();\n            this.reproject_();\n          }\n        }, this);\n        this.sourceImage_.load();\n      }\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  unlistenSource_() {\n    unlistenByKey(\n    /** @type {!import(\"../events.js\").EventsKey} */\n    this.sourceListenerKey_);\n    this.sourceListenerKey_ = null;\n  }\n\n}\n\nexport default ReprojImage;","map":null,"metadata":{},"sourceType":"module"}